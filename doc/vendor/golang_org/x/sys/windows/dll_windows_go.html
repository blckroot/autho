<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>dll_windows.go - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../../../";
  var index_rel_prefix = "../../../../../";
</script>

<script src="../../../../../js/navigation.js" defer></script>
<script src="../../../../../js/search.js" defer></script>
<script src="../../../../../js/search_index.js" defer></script>
<script src="../../../../../js/searcher.js" defer></script>
<script src="../../../../../js/darkfish.js" defer></script>

<link href="../../../../../css/fonts.css" rel="stylesheet">
<link href="../../../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../../../LICENSE.html">LICENSE</a>
    <li><a href="../../../../../README_md.html">README</a>
    <li><a href="../../../../../api/access_token_go.html">access_token.go</a>
    <li><a href="../../../../../api/access_token_test_go.html">access_token_test.go</a>
    <li><a href="../../../../../api/form_go.html">form.go</a>
    <li><a href="../../../../../api/form_test_go.html">form_test.go</a>
    <li><a href="../../../../../device/device_flow_go.html">device_flow.go</a>
    <li><a href="../../../../../device/device_flow_test_go.html">device_flow_test.go</a>
    <li><a href="../../../../../device/examples_test_go.html">examples_test.go</a>
    <li><a href="../../../../../device/poller_go.html">poller.go</a>
    <li><a href="../../../../../examples_test_go.html">examples_test.go</a>
    <li><a href="../../../../../go_mod.html">go.mod</a>
    <li><a href="../../../../../go_sum.html">go.sum</a>
    <li><a href="../../../../../oauth_go.html">oauth.go</a>
    <li><a href="../../../../../oauth_device_go.html">oauth_device.go</a>
    <li><a href="../../../../../oauth_webapp_go.html">oauth_webapp.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/README_md.html">README</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_go.html">browser.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_darwin_go.html">browser_darwin.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_freebsd_go.html">browser_freebsd.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_linux_go.html">browser_linux.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_openbsd_go.html">browser_openbsd.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_unsupported_go.html">browser_unsupported.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_windows_go.html">browser_windows.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/zbrowser_windows_go.html">zbrowser_windows.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/README_md.html">README</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/api/access_token_go.html">access_token.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/api/form_go.html">form.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/device/device_flow_go.html">device_flow.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/device/poller_go.html">poller.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/oauth_go.html">oauth.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/oauth_device_go.html">oauth_device.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/oauth_webapp_go.html">oauth_webapp.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/webapp/local_server_go.html">local_server.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/webapp/webapp_flow_go.html">webapp_flow.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/PATENTS.html">PATENTS</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/internal/unsafeheader/unsafeheader_go.html">unsafeheader.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/aliases_go.html">aliases.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/dll_windows_go.html">dll_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/empty_s.html">empty.s</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/env_windows_go.html">env_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/eventlog_go.html">eventlog.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/exec_windows_go.html">exec_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/memory_windows_go.html">memory_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/mkerrors_bash.html">mkerrors.bash</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/mkknownfolderids_bash.html">mkknownfolderids.bash</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/mksyscall_go.html">mksyscall.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/race_go.html">race.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/race0_go.html">race0.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/security_windows_go.html">security_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/service_go.html">service.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/setupapi_windows_go.html">setupapi_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/str_go.html">str.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/syscall_go.html">syscall.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/syscall_windows_go.html">syscall_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_go.html">types_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_386_go.html">types_windows_386.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_amd64_go.html">types_windows_amd64.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_arm_go.html">types_windows_arm.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_arm64_go.html">types_windows_arm64.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/zerrors_windows_go.html">zerrors_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/zknownfolderids_windows_go.html">zknownfolderids_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/zsyscall_windows_go.html">zsyscall_windows.go</a>
    <li><a href="../../../../../vendor/modules_txt.html">modules</a>
    <li><a href="../../../../../webapp/examples_test_go.html">examples_test.go</a>
    <li><a href="../../../../../webapp/local_server_go.html">local_server.go</a>
    <li><a href="../../../../../webapp/local_server_test_go.html">local_server_test.go</a>
    <li><a href="../../../../../webapp/webapp_flow_go.html">webapp_flow.go</a>
    <li><a href="../../../../../webapp/webapp_flow_test_go.html">webapp_flow_test.go</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page vendor/golang.org/x/sys/windows/dll_windows.go">

<p>// Copyright 2011 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the <a href="../../../../../LICENSE.html">LICENSE</a> file.</p>

<p>package windows</p>

<p>import (</p>

<pre class="ruby"><span class="ruby-string">&quot;sync&quot;</span>
<span class="ruby-string">&quot;sync/atomic&quot;</span>
<span class="ruby-string">&quot;syscall&quot;</span>
<span class="ruby-string">&quot;unsafe&quot;</span>
</pre>

<p>)</p>

<p>// We need to use LoadLibrary and GetProcAddress from the Go runtime, because // the these symbols are loaded by the system linker and are required to // dynamically load additional symbols. Note that in the Go runtime, these // return syscall.Handle and syscall.Errno, but these are the same, in fact, // as windows.Handle and windows.Errno, and we intend to keep these the same.</p>

<p>//go:linkname syscall_loadlibrary syscall.loadlibrary func syscall_loadlibrary(filename *uint16) (handle Handle, err Errno)</p>

<p>//go:linkname syscall_getprocaddress syscall.getprocaddress func syscall_getprocaddress(handle Handle, procname *uint8) (proc uintptr, err Errno)</p>

<p>// DLLError describes reasons for DLL load failures. type DLLError struct {</p>

<pre class="ruby"><span class="ruby-constant">Err</span>     <span class="ruby-identifier">error</span>
<span class="ruby-constant">ObjName</span> <span class="ruby-identifier">string</span>
<span class="ruby-constant">Msg</span>     <span class="ruby-identifier">string</span>
</pre>

<p>}</p>

<p>func (e *DLLError) Error() string { return e.Msg }</p>

<p>func (e *DLLError) Unwrap() error { return e.Err }</p>

<p>// A DLL implements access to a single DLL. type DLL struct {</p>

<pre class="ruby"><span class="ruby-constant">Name</span>   <span class="ruby-identifier">string</span>
<span class="ruby-constant">Handle</span> <span class="ruby-constant">Handle</span>
</pre>

<p>}</p>

<p>// LoadDLL loads DLL file into memory. // // Warning: using LoadDLL without an absolute path name is subject to // DLL preloading attacks. To safely load a system DLL, use LazyDLL // with System set to true, or use LoadLibraryEx directly. func LoadDLL(name string) (dll *DLL, err error) {</p>

<pre>namep, err := UTF16PtrFromString(name)
if err != nil {
        return nil, err
}
h, e := syscall_loadlibrary(namep)
if e != 0 {
        return nil, &amp;DLLError{
                Err:     e,
                ObjName: name,
                Msg:     &quot;Failed to load &quot; + name + &quot;: &quot; + e.Error(),
        }
}
d := &amp;DLL{
        Name:   name,
        Handle: h,
}
return d, nil</pre>

<p>}</p>

<p>// MustLoadDLL is like LoadDLL but panics if load operation failes. func MustLoadDLL(name string) *DLL {</p>

<pre>d, e := LoadDLL(name)
if e != nil {
        panic(e)
}
return d</pre>

<p>}</p>

<p>// FindProc searches DLL d for procedure named name and returns *Proc // if found. It returns an error if search fails. func (d *DLL) FindProc(name string) (proc *Proc, err error) {</p>

<pre>namep, err := BytePtrFromString(name)
if err != nil {
        return nil, err
}
a, e := syscall_getprocaddress(d.Handle, namep)
if e != 0 {
        return nil, &amp;DLLError{
                Err:     e,
                ObjName: name,
                Msg:     &quot;Failed to find &quot; + name + &quot; procedure in &quot; + d.Name + &quot;: &quot; + e.Error(),
        }
}
p := &amp;Proc{
        Dll:  d,
        Name: name,
        addr: a,
}
return p, nil</pre>

<p>}</p>

<p>// MustFindProc is like FindProc but panics if search fails. func (d *DLL) MustFindProc(name string) *Proc {</p>

<pre>p, e := d.FindProc(name)
if e != nil {
        panic(e)
}
return p</pre>

<p>}</p>

<p>// FindProcByOrdinal searches DLL d for procedure by ordinal and returns *Proc // if found. It returns an error if search fails. func (d *DLL) FindProcByOrdinal(ordinal uintptr) (proc *Proc, err error) {</p>

<pre>a, e := GetProcAddressByOrdinal(d.Handle, ordinal)
name := &quot;#&quot; + itoa(int(ordinal))
if e != nil {
        return nil, &amp;DLLError{
                Err:     e,
                ObjName: name,
                Msg:     &quot;Failed to find &quot; + name + &quot; procedure in &quot; + d.Name + &quot;: &quot; + e.Error(),
        }
}
p := &amp;Proc{
        Dll:  d,
        Name: name,
        addr: a,
}
return p, nil</pre>

<p>}</p>

<p>// MustFindProcByOrdinal is like FindProcByOrdinal but panics if search fails. func (d *DLL) MustFindProcByOrdinal(ordinal uintptr) *Proc {</p>

<pre>p, e := d.FindProcByOrdinal(ordinal)
if e != nil {
        panic(e)
}
return p</pre>

<p>}</p>

<p>// Release unloads DLL d from memory. func (d *DLL) Release() (err error) {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-constant">FreeLibrary</span>(<span class="ruby-identifier">d</span>.<span class="ruby-constant">Handle</span>)
</pre>

<p>}</p>

<p>// A Proc implements access to a procedure inside a DLL. type Proc struct {</p>

<pre class="ruby"><span class="ruby-constant">Dll</span>  <span class="ruby-operator">*</span><span class="ruby-constant">DLL</span>
<span class="ruby-constant">Name</span> <span class="ruby-identifier">string</span>
<span class="ruby-identifier">addr</span> <span class="ruby-identifier">uintptr</span>
</pre>

<p>}</p>

<p>// Addr returns the address of the procedure represented by p. // The return value can be passed to Syscall to run the procedure. func (p *Proc) Addr() uintptr {</p>

<pre class="ruby"><span class="ruby-keyword">return</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">addr</span>
</pre>

<p>}</p>

<p>//go:uintptrescapes</p>

<p>// Call executes procedure p with arguments a. It will panic, if more than 15 arguments // are supplied. // // The returned error is always non-nil, constructed from the result of GetLastError. // Callers must inspect the primary return value to decide whether an error occurred // (according to the semantics of the specific function being called) before consulting // the error. The error will be guaranteed to contain windows.Errno. func (p *Proc) Call(a …uintptr) (r1, r2 uintptr, lastErr error) {</p>

<pre>switch len(a) {
case 0:
        return syscall.Syscall(p.Addr(), uintptr(len(a)), 0, 0, 0)
case 1:
        return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], 0, 0)
case 2:
        return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], a[1], 0)
case 3:
        return syscall.Syscall(p.Addr(), uintptr(len(a)), a[0], a[1], a[2])
case 4:
        return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], 0, 0)
case 5:
        return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], 0)
case 6:
        return syscall.Syscall6(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5])
case 7:
        return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], 0, 0)
case 8:
        return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], 0)
case 9:
        return syscall.Syscall9(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
case 10:
        return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], 0, 0)
case 11:
        return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], 0)
case 12:
        return syscall.Syscall12(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])
case 13:
        return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], 0, 0)
case 14:
        return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], 0)
case 15:
        return syscall.Syscall15(p.Addr(), uintptr(len(a)), a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14])
default:
        panic(&quot;Call &quot; + p.Name + &quot; with too many arguments &quot; + itoa(len(a)) + &quot;.&quot;)
}</pre>

<p>}</p>

<p>// A LazyDLL implements access to a single DLL. // It will delay the load of the DLL until the first // call to its Handle method or to one of its // LazyProc’s Addr method. type LazyDLL struct {</p>

<pre>Name string

// System determines whether the DLL must be loaded from the
// Windows System directory, bypassing the normal DLL search
// path.
System bool

mu  sync.Mutex
dll *DLL // non nil once DLL is loaded</pre>

<p>}</p>

<p>// Load loads DLL file d.Name into memory. It returns an error if fails. // Load will not try to load DLL, if it is already loaded into memory. func (d *LazyDLL) Load() error {</p>

<pre>// Non-racy version of:
// if d.dll != nil {
if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;d.dll))) != nil {
        return nil
}
d.mu.Lock()
defer d.mu.Unlock()
if d.dll != nil {
        return nil
}

// kernel32.dll is special, since it&#39;s where LoadLibraryEx comes from.
// The kernel already special-cases its name, so it&#39;s always
// loaded from system32.
var dll *DLL
var err error
if d.Name == &quot;kernel32.dll&quot; {
        dll, err = LoadDLL(d.Name)
} else {
        dll, err = loadLibraryEx(d.Name, d.System)
}
if err != nil {
        return err
}

// Non-racy version of:
// d.dll = dll
atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&amp;d.dll)), unsafe.Pointer(dll))
return nil</pre>

<p>}</p>

<p>// mustLoad is like Load but panics if search fails. func (d *LazyDLL) mustLoad() {</p>

<pre>e := d.Load()
if e != nil {
        panic(e)
}</pre>

<p>}</p>

<p>// Handle returns d’s module handle. func (d *LazyDLL) Handle() uintptr {</p>

<pre class="ruby"><span class="ruby-identifier">d</span>.<span class="ruby-identifier">mustLoad</span>()
<span class="ruby-keyword">return</span> <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">d</span>.<span class="ruby-identifier">dll</span>.<span class="ruby-constant">Handle</span>)
</pre>

<p>}</p>

<p>// NewProc returns a LazyProc for accessing the named procedure in the DLL d. func (d *LazyDLL) NewProc(name string) *LazyProc {</p>

<pre>return &amp;LazyProc{l: d, Name: name}</pre>

<p>}</p>

<p>// NewLazyDLL creates new LazyDLL associated with DLL file. func NewLazyDLL(name string) *LazyDLL {</p>

<pre>return &amp;LazyDLL{Name: name}</pre>

<p>}</p>

<p>// NewLazySystemDLL is like NewLazyDLL, but will only // search Windows System directory for the DLL if name is // a base name (like “advapi32.dll”). func NewLazySystemDLL(name string) *LazyDLL {</p>

<pre>return &amp;LazyDLL{Name: name, System: true}</pre>

<p>}</p>

<p>// A LazyProc implements access to a procedure inside a LazyDLL. // It delays the lookup until the Addr method is called. type LazyProc struct {</p>

<pre class="ruby"><span class="ruby-constant">Name</span> <span class="ruby-identifier">string</span>

<span class="ruby-identifier">mu</span>   <span class="ruby-identifier">sync</span>.<span class="ruby-constant">Mutex</span>
<span class="ruby-identifier">l</span>    <span class="ruby-operator">*</span><span class="ruby-constant">LazyDLL</span>
<span class="ruby-identifier">proc</span> <span class="ruby-operator">*</span><span class="ruby-constant">Proc</span>
</pre>

<p>}</p>

<p>// Find searches DLL for procedure named p.Name. It returns // an error if search fails. Find will not search procedure, // if it is already found and loaded into memory. func (p *LazyProc) Find() error {</p>

<pre>// Non-racy version of:
// if p.proc == nil {
if atomic.LoadPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;p.proc))) == nil {
        p.mu.Lock()
        defer p.mu.Unlock()
        if p.proc == nil {
                e := p.l.Load()
                if e != nil {
                        return e
                }
                proc, e := p.l.dll.FindProc(p.Name)
                if e != nil {
                        return e
                }
                // Non-racy version of:
                // p.proc = proc
                atomic.StorePointer((*unsafe.Pointer)(unsafe.Pointer(&amp;p.proc)), unsafe.Pointer(proc))
        }
}
return nil</pre>

<p>}</p>

<p>// mustFind is like Find but panics if search fails. func (p *LazyProc) mustFind() {</p>

<pre>e := p.Find()
if e != nil {
        panic(e)
}</pre>

<p>}</p>

<p>// Addr returns the address of the procedure represented by p. // The return value can be passed to Syscall to run the procedure. // It will panic if the procedure cannot be found. func (p *LazyProc) Addr() uintptr {</p>

<pre class="ruby"><span class="ruby-identifier">p</span>.<span class="ruby-identifier">mustFind</span>()
<span class="ruby-keyword">return</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">proc</span>.<span class="ruby-constant">Addr</span>()
</pre>

<p>}</p>

<p>//go:uintptrescapes</p>

<p>// Call executes procedure p with arguments a. It will panic, if more than 15 arguments // are supplied. It will also panic if the procedure cannot be found. // // The returned error is always non-nil, constructed from the result of GetLastError. // Callers must inspect the primary return value to decide whether an error occurred // (according to the semantics of the specific function being called) before consulting // the error. The error will be guaranteed to contain windows.Errno. func (p *LazyProc) Call(a …uintptr) (r1, r2 uintptr, lastErr error) {</p>

<pre class="ruby"><span class="ruby-identifier">p</span>.<span class="ruby-identifier">mustFind</span>()
<span class="ruby-keyword">return</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">proc</span>.<span class="ruby-constant">Call</span>(<span class="ruby-identifier">a</span><span class="ruby-operator">...</span>)
</pre>

<p>}</p>

<p>var canDoSearchSystem32Once struct {</p>

<pre class="ruby"><span class="ruby-identifier">sync</span>.<span class="ruby-constant">Once</span>
<span class="ruby-identifier">v</span> <span class="ruby-identifier">bool</span>
</pre>

<p>}</p>

<p>func initCanDoSearchSystem32() {</p>

<pre>// https://msdn.microsoft.com/en-us/library/ms684179(v=vs.85).aspx says:
// &quot;Windows 7, Windows Server 2008 R2, Windows Vista, and Windows
// Server 2008: The LOAD_LIBRARY_SEARCH_* flags are available on
// systems that have KB2533623 installed. To determine whether the
// flags are available, use GetProcAddress to get the address of the
// AddDllDirectory, RemoveDllDirectory, or SetDefaultDllDirectories
// function. If GetProcAddress succeeds, the LOAD_LIBRARY_SEARCH_*
// flags can be used with LoadLibraryEx.&quot;
canDoSearchSystem32Once.v = (modkernel32.NewProc(&quot;AddDllDirectory&quot;).Find() == nil)</pre>

<p>}</p>

<p>func canDoSearchSystem32() bool {</p>

<pre class="ruby"><span class="ruby-identifier">canDoSearchSystem32Once</span>.<span class="ruby-constant">Do</span>(<span class="ruby-identifier">initCanDoSearchSystem32</span>)
<span class="ruby-keyword">return</span> <span class="ruby-identifier">canDoSearchSystem32Once</span>.<span class="ruby-identifier">v</span>
</pre>

<p>}</p>

<p>func isBaseName(name string) bool {</p>

<pre>for _, c := range name {
        if c == &#39;:&#39; || c == &#39;/&#39; || c == &#39;\\&#39; {
                return false
        }
}
return true</pre>

<p>}</p>

<p>// loadLibraryEx wraps the Windows LoadLibraryEx function. // // See <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx">msdn.microsoft.com/en-us/library/windows/desktop/ms684179(v=vs.85).aspx</a> // // If name is not an absolute path, LoadLibraryEx searches for the DLL // in a variety of automatic locations unless constrained by flags. // See: <a href="https://msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx">msdn.microsoft.com/en-us/library/ff919712%28VS.85%29.aspx</a> func loadLibraryEx(name string, system bool) (*DLL, error) {</p>

<pre>loadDLL := name
var flags uintptr
if system {
        if canDoSearchSystem32() {
                flags = LOAD_LIBRARY_SEARCH_SYSTEM32
        } else if isBaseName(name) {
                // WindowsXP or unpatched Windows machine
                // trying to load &quot;foo.dll&quot; out of the system
                // folder, but LoadLibraryEx doesn&#39;t support
                // that yet on their system, so emulate it.
                systemdir, err := GetSystemDirectory()
                if err != nil {
                        return nil, err
                }
                loadDLL = systemdir + &quot;\\&quot; + name
        }
}
h, err := LoadLibraryEx(loadDLL, 0, flags)
if err != nil {
        return nil, err
}
return &amp;DLL{Name: name, Handle: h}, nil</pre>

<p>}</p>

<p>type errString string</p>

<p>func (s errString) Error() string { return string(s) }</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

