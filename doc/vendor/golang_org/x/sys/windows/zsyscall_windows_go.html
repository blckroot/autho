<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>zsyscall_windows.go - RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../../../../../";
  var index_rel_prefix = "../../../../../";
</script>

<script src="../../../../../js/navigation.js" defer></script>
<script src="../../../../../js/search.js" defer></script>
<script src="../../../../../js/search_index.js" defer></script>
<script src="../../../../../js/searcher.js" defer></script>
<script src="../../../../../js/darkfish.js" defer></script>

<link href="../../../../../css/fonts.css" rel="stylesheet">
<link href="../../../../../css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../../../../../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../../../../../table_of_contents.html#pages">Pages</a>
    <a href="../../../../../table_of_contents.html#classes">Classes</a>
    <a href="../../../../../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="../../../../../LICENSE.html">LICENSE</a>
    <li><a href="../../../../../README_md.html">README</a>
    <li><a href="../../../../../api/access_token_go.html">access_token.go</a>
    <li><a href="../../../../../api/access_token_test_go.html">access_token_test.go</a>
    <li><a href="../../../../../api/form_go.html">form.go</a>
    <li><a href="../../../../../api/form_test_go.html">form_test.go</a>
    <li><a href="../../../../../device/device_flow_go.html">device_flow.go</a>
    <li><a href="../../../../../device/device_flow_test_go.html">device_flow_test.go</a>
    <li><a href="../../../../../device/examples_test_go.html">examples_test.go</a>
    <li><a href="../../../../../device/poller_go.html">poller.go</a>
    <li><a href="../../../../../examples_test_go.html">examples_test.go</a>
    <li><a href="../../../../../go_mod.html">go.mod</a>
    <li><a href="../../../../../go_sum.html">go.sum</a>
    <li><a href="../../../../../oauth_go.html">oauth.go</a>
    <li><a href="../../../../../oauth_device_go.html">oauth_device.go</a>
    <li><a href="../../../../../oauth_webapp_go.html">oauth_webapp.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/README_md.html">README</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_go.html">browser.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_darwin_go.html">browser_darwin.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_freebsd_go.html">browser_freebsd.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_linux_go.html">browser_linux.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_openbsd_go.html">browser_openbsd.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_unsupported_go.html">browser_unsupported.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/browser_windows_go.html">browser_windows.go</a>
    <li><a href="../../../../../vendor/github_com/cli/browser/zbrowser_windows_go.html">zbrowser_windows.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/README_md.html">README</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/api/access_token_go.html">access_token.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/api/form_go.html">form.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/device/device_flow_go.html">device_flow.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/device/poller_go.html">poller.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/oauth_go.html">oauth.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/oauth_device_go.html">oauth_device.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/oauth_webapp_go.html">oauth_webapp.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/webapp/local_server_go.html">local_server.go</a>
    <li><a href="../../../../../vendor/github_com/cli/oauth/webapp/webapp_flow_go.html">webapp_flow.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/LICENSE.html">LICENSE</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/PATENTS.html">PATENTS</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/internal/unsafeheader/unsafeheader_go.html">unsafeheader.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/aliases_go.html">aliases.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/dll_windows_go.html">dll_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/empty_s.html">empty.s</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/env_windows_go.html">env_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/eventlog_go.html">eventlog.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/exec_windows_go.html">exec_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/memory_windows_go.html">memory_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/mkerrors_bash.html">mkerrors.bash</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/mkknownfolderids_bash.html">mkknownfolderids.bash</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/mksyscall_go.html">mksyscall.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/race_go.html">race.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/race0_go.html">race0.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/security_windows_go.html">security_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/service_go.html">service.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/setupapi_windows_go.html">setupapi_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/str_go.html">str.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/syscall_go.html">syscall.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/syscall_windows_go.html">syscall_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_go.html">types_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_386_go.html">types_windows_386.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_amd64_go.html">types_windows_amd64.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_arm_go.html">types_windows_arm.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/types_windows_arm64_go.html">types_windows_arm64.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/zerrors_windows_go.html">zerrors_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/zknownfolderids_windows_go.html">zknownfolderids_windows.go</a>
    <li><a href="../../../../../vendor/golang_org/x/sys/windows/zsyscall_windows_go.html">zsyscall_windows.go</a>
    <li><a href="../../../../../vendor/modules_txt.html">modules</a>
    <li><a href="../../../../../webapp/examples_test_go.html">examples_test.go</a>
    <li><a href="../../../../../webapp/local_server_go.html">local_server.go</a>
    <li><a href="../../../../../webapp/local_server_test_go.html">local_server_test.go</a>
    <li><a href="../../../../../webapp/webapp_flow_go.html">webapp_flow.go</a>
    <li><a href="../../../../../webapp/webapp_flow_test_go.html">webapp_flow_test.go</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-label="Page vendor/golang.org/x/sys/windows/zsyscall_windows.go">

<p>// Code generated by ‘go generate’; DO NOT EDIT.</p>

<p>package windows</p>

<p>import (</p>

<pre class="ruby"><span class="ruby-string">&quot;syscall&quot;</span>
<span class="ruby-string">&quot;unsafe&quot;</span>
</pre>

<p>)</p>

<p>var _ unsafe.Pointer</p>

<p>// Do the interface allocations only once for common // Errno values. const (</p>

<pre class="ruby"><span class="ruby-identifier">errnoERROR_IO_PENDING</span> = <span class="ruby-value">997</span>
</pre>

<p>)</p>

<p>var (</p>

<pre class="ruby"><span class="ruby-identifier">errERROR_IO_PENDING</span> <span class="ruby-identifier">error</span> = <span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Errno</span>(<span class="ruby-identifier">errnoERROR_IO_PENDING</span>)
<span class="ruby-identifier">errERROR_EINVAL</span>     <span class="ruby-identifier">error</span> = <span class="ruby-identifier">syscall</span>.<span class="ruby-constant">EINVAL</span>
</pre>

<p>)</p>

<p>// errnoErr returns common boxed Errno values, to prevent // allocations at runtime. func errnoErr(e syscall.Errno) error {</p>

<pre>switch e {
case 0:
        return errERROR_EINVAL
case errnoERROR_IO_PENDING:
        return errERROR_IO_PENDING
}
// TODO: add more here, after collecting data on the common
// error values see on Windows. (perhaps when running
// all.bat?)
return e</pre>

<p>}</p>

<p>var (</p>

<pre class="ruby"><span class="ruby-identifier">modCfgMgr32</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;CfgMgr32.dll&quot;</span>)
<span class="ruby-identifier">modadvapi32</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;advapi32.dll&quot;</span>)
<span class="ruby-identifier">modcrypt32</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;crypt32.dll&quot;</span>)
<span class="ruby-identifier">moddnsapi</span>   = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;dnsapi.dll&quot;</span>)
<span class="ruby-identifier">moddwmapi</span>   = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;dwmapi.dll&quot;</span>)
<span class="ruby-identifier">modiphlpapi</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;iphlpapi.dll&quot;</span>)
<span class="ruby-identifier">modkernel32</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;kernel32.dll&quot;</span>)
<span class="ruby-identifier">modmswsock</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;mswsock.dll&quot;</span>)
<span class="ruby-identifier">modnetapi32</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;netapi32.dll&quot;</span>)
<span class="ruby-identifier">modntdll</span>    = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;ntdll.dll&quot;</span>)
<span class="ruby-identifier">modole32</span>    = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;ole32.dll&quot;</span>)
<span class="ruby-identifier">modpsapi</span>    = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;psapi.dll&quot;</span>)
<span class="ruby-identifier">modsechost</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;sechost.dll&quot;</span>)
<span class="ruby-identifier">modsecur32</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;secur32.dll&quot;</span>)
<span class="ruby-identifier">modsetupapi</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;setupapi.dll&quot;</span>)
<span class="ruby-identifier">modshell32</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;shell32.dll&quot;</span>)
<span class="ruby-identifier">moduser32</span>   = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;user32.dll&quot;</span>)
<span class="ruby-identifier">moduserenv</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;userenv.dll&quot;</span>)
<span class="ruby-identifier">modversion</span>  = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;version.dll&quot;</span>)
<span class="ruby-identifier">modwintrust</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;wintrust.dll&quot;</span>)
<span class="ruby-identifier">modws2_32</span>   = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;ws2_32.dll&quot;</span>)
<span class="ruby-identifier">modwtsapi32</span> = <span class="ruby-constant">NewLazySystemDLL</span>(<span class="ruby-string">&quot;wtsapi32.dll&quot;</span>)

<span class="ruby-identifier">procCM_Get_DevNode_Status</span>                                = <span class="ruby-identifier">modCfgMgr32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CM_Get_DevNode_Status&quot;</span>)
<span class="ruby-identifier">procCM_Get_Device_Interface_ListW</span>                        = <span class="ruby-identifier">modCfgMgr32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CM_Get_Device_Interface_ListW&quot;</span>)
<span class="ruby-identifier">procCM_Get_Device_Interface_List_SizeW</span>                   = <span class="ruby-identifier">modCfgMgr32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CM_Get_Device_Interface_List_SizeW&quot;</span>)
<span class="ruby-identifier">procCM_MapCrToWin32Err</span>                                   = <span class="ruby-identifier">modCfgMgr32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CM_MapCrToWin32Err&quot;</span>)
<span class="ruby-identifier">procAdjustTokenGroups</span>                                    = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;AdjustTokenGroups&quot;</span>)
<span class="ruby-identifier">procAdjustTokenPrivileges</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;AdjustTokenPrivileges&quot;</span>)
<span class="ruby-identifier">procAllocateAndInitializeSid</span>                             = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;AllocateAndInitializeSid&quot;</span>)
<span class="ruby-identifier">procBuildSecurityDescriptorW</span>                             = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;BuildSecurityDescriptorW&quot;</span>)
<span class="ruby-identifier">procChangeServiceConfig2W</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ChangeServiceConfig2W&quot;</span>)
<span class="ruby-identifier">procChangeServiceConfigW</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ChangeServiceConfigW&quot;</span>)
<span class="ruby-identifier">procCheckTokenMembership</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CheckTokenMembership&quot;</span>)
<span class="ruby-identifier">procCloseServiceHandle</span>                                   = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CloseServiceHandle&quot;</span>)
<span class="ruby-identifier">procControlService</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ControlService&quot;</span>)
<span class="ruby-identifier">procConvertSecurityDescriptorToStringSecurityDescriptorW</span> = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ConvertSecurityDescriptorToStringSecurityDescriptorW&quot;</span>)
<span class="ruby-identifier">procConvertSidToStringSidW</span>                               = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ConvertSidToStringSidW&quot;</span>)
<span class="ruby-identifier">procConvertStringSecurityDescriptorToSecurityDescriptorW</span> = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ConvertStringSecurityDescriptorToSecurityDescriptorW&quot;</span>)
<span class="ruby-identifier">procConvertStringSidToSidW</span>                               = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ConvertStringSidToSidW&quot;</span>)
<span class="ruby-identifier">procCopySid</span>                                              = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CopySid&quot;</span>)
<span class="ruby-identifier">procCreateProcessAsUserW</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateProcessAsUserW&quot;</span>)
<span class="ruby-identifier">procCreateServiceW</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateServiceW&quot;</span>)
<span class="ruby-identifier">procCreateWellKnownSid</span>                                   = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateWellKnownSid&quot;</span>)
<span class="ruby-identifier">procCryptAcquireContextW</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptAcquireContextW&quot;</span>)
<span class="ruby-identifier">procCryptGenRandom</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptGenRandom&quot;</span>)
<span class="ruby-identifier">procCryptReleaseContext</span>                                  = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptReleaseContext&quot;</span>)
<span class="ruby-identifier">procDeleteService</span>                                        = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DeleteService&quot;</span>)
<span class="ruby-identifier">procDeregisterEventSource</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DeregisterEventSource&quot;</span>)
<span class="ruby-identifier">procDuplicateTokenEx</span>                                     = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DuplicateTokenEx&quot;</span>)
<span class="ruby-identifier">procEnumServicesStatusExW</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EnumServicesStatusExW&quot;</span>)
<span class="ruby-identifier">procEqualSid</span>                                             = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EqualSid&quot;</span>)
<span class="ruby-identifier">procFreeSid</span>                                              = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FreeSid&quot;</span>)
<span class="ruby-identifier">procGetLengthSid</span>                                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetLengthSid&quot;</span>)
<span class="ruby-identifier">procGetNamedSecurityInfoW</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetNamedSecurityInfoW&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorControl</span>                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorControl&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorDacl</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorDacl&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorGroup</span>                           = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorGroup&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorLength</span>                          = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorLength&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorOwner</span>                           = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorOwner&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorRMControl</span>                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorRMControl&quot;</span>)
<span class="ruby-identifier">procGetSecurityDescriptorSacl</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityDescriptorSacl&quot;</span>)
<span class="ruby-identifier">procGetSecurityInfo</span>                                      = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSecurityInfo&quot;</span>)
<span class="ruby-identifier">procGetSidIdentifierAuthority</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSidIdentifierAuthority&quot;</span>)
<span class="ruby-identifier">procGetSidSubAuthority</span>                                   = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSidSubAuthority&quot;</span>)
<span class="ruby-identifier">procGetSidSubAuthorityCount</span>                              = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSidSubAuthorityCount&quot;</span>)
<span class="ruby-identifier">procGetTokenInformation</span>                                  = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetTokenInformation&quot;</span>)
<span class="ruby-identifier">procImpersonateSelf</span>                                      = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ImpersonateSelf&quot;</span>)
<span class="ruby-identifier">procInitializeSecurityDescriptor</span>                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;InitializeSecurityDescriptor&quot;</span>)
<span class="ruby-identifier">procInitiateSystemShutdownExW</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;InitiateSystemShutdownExW&quot;</span>)
<span class="ruby-identifier">procIsTokenRestricted</span>                                    = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsTokenRestricted&quot;</span>)
<span class="ruby-identifier">procIsValidSecurityDescriptor</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsValidSecurityDescriptor&quot;</span>)
<span class="ruby-identifier">procIsValidSid</span>                                           = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsValidSid&quot;</span>)
<span class="ruby-identifier">procIsWellKnownSid</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsWellKnownSid&quot;</span>)
<span class="ruby-identifier">procLookupAccountNameW</span>                                   = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LookupAccountNameW&quot;</span>)
<span class="ruby-identifier">procLookupAccountSidW</span>                                    = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LookupAccountSidW&quot;</span>)
<span class="ruby-identifier">procLookupPrivilegeValueW</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LookupPrivilegeValueW&quot;</span>)
<span class="ruby-identifier">procMakeAbsoluteSD</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MakeAbsoluteSD&quot;</span>)
<span class="ruby-identifier">procMakeSelfRelativeSD</span>                                   = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MakeSelfRelativeSD&quot;</span>)
<span class="ruby-identifier">procNotifyServiceStatusChangeW</span>                           = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NotifyServiceStatusChangeW&quot;</span>)
<span class="ruby-identifier">procOpenProcessToken</span>                                     = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenProcessToken&quot;</span>)
<span class="ruby-identifier">procOpenSCManagerW</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenSCManagerW&quot;</span>)
<span class="ruby-identifier">procOpenServiceW</span>                                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenServiceW&quot;</span>)
<span class="ruby-identifier">procOpenThreadToken</span>                                      = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenThreadToken&quot;</span>)
<span class="ruby-identifier">procQueryServiceConfig2W</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryServiceConfig2W&quot;</span>)
<span class="ruby-identifier">procQueryServiceConfigW</span>                                  = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryServiceConfigW&quot;</span>)
<span class="ruby-identifier">procQueryServiceDynamicInformation</span>                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryServiceDynamicInformation&quot;</span>)
<span class="ruby-identifier">procQueryServiceLockStatusW</span>                              = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryServiceLockStatusW&quot;</span>)
<span class="ruby-identifier">procQueryServiceStatus</span>                                   = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryServiceStatus&quot;</span>)
<span class="ruby-identifier">procQueryServiceStatusEx</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryServiceStatusEx&quot;</span>)
<span class="ruby-identifier">procRegCloseKey</span>                                          = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegCloseKey&quot;</span>)
<span class="ruby-identifier">procRegEnumKeyExW</span>                                        = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegEnumKeyExW&quot;</span>)
<span class="ruby-identifier">procRegNotifyChangeKeyValue</span>                              = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegNotifyChangeKeyValue&quot;</span>)
<span class="ruby-identifier">procRegOpenKeyExW</span>                                        = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegOpenKeyExW&quot;</span>)
<span class="ruby-identifier">procRegQueryInfoKeyW</span>                                     = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegQueryInfoKeyW&quot;</span>)
<span class="ruby-identifier">procRegQueryValueExW</span>                                     = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegQueryValueExW&quot;</span>)
<span class="ruby-identifier">procRegisterEventSourceW</span>                                 = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegisterEventSourceW&quot;</span>)
<span class="ruby-identifier">procRegisterServiceCtrlHandlerExW</span>                        = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RegisterServiceCtrlHandlerExW&quot;</span>)
<span class="ruby-identifier">procReportEventW</span>                                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ReportEventW&quot;</span>)
<span class="ruby-identifier">procRevertToSelf</span>                                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RevertToSelf&quot;</span>)
<span class="ruby-identifier">procSetEntriesInAclW</span>                                     = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetEntriesInAclW&quot;</span>)
<span class="ruby-identifier">procSetKernelObjectSecurity</span>                              = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetKernelObjectSecurity&quot;</span>)
<span class="ruby-identifier">procSetNamedSecurityInfoW</span>                                = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetNamedSecurityInfoW&quot;</span>)
<span class="ruby-identifier">procSetSecurityDescriptorControl</span>                         = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityDescriptorControl&quot;</span>)
<span class="ruby-identifier">procSetSecurityDescriptorDacl</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityDescriptorDacl&quot;</span>)
<span class="ruby-identifier">procSetSecurityDescriptorGroup</span>                           = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityDescriptorGroup&quot;</span>)
<span class="ruby-identifier">procSetSecurityDescriptorOwner</span>                           = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityDescriptorOwner&quot;</span>)
<span class="ruby-identifier">procSetSecurityDescriptorRMControl</span>                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityDescriptorRMControl&quot;</span>)
<span class="ruby-identifier">procSetSecurityDescriptorSacl</span>                            = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityDescriptorSacl&quot;</span>)
<span class="ruby-identifier">procSetSecurityInfo</span>                                      = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetSecurityInfo&quot;</span>)
<span class="ruby-identifier">procSetServiceStatus</span>                                     = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetServiceStatus&quot;</span>)
<span class="ruby-identifier">procSetThreadToken</span>                                       = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetThreadToken&quot;</span>)
<span class="ruby-identifier">procSetTokenInformation</span>                                  = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetTokenInformation&quot;</span>)
<span class="ruby-identifier">procStartServiceCtrlDispatcherW</span>                          = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;StartServiceCtrlDispatcherW&quot;</span>)
<span class="ruby-identifier">procStartServiceW</span>                                        = <span class="ruby-identifier">modadvapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;StartServiceW&quot;</span>)
<span class="ruby-identifier">procCertAddCertificateContextToStore</span>                     = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertAddCertificateContextToStore&quot;</span>)
<span class="ruby-identifier">procCertCloseStore</span>                                       = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertCloseStore&quot;</span>)
<span class="ruby-identifier">procCertCreateCertificateContext</span>                         = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertCreateCertificateContext&quot;</span>)
<span class="ruby-identifier">procCertDeleteCertificateFromStore</span>                       = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertDeleteCertificateFromStore&quot;</span>)
<span class="ruby-identifier">procCertDuplicateCertificateContext</span>                      = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertDuplicateCertificateContext&quot;</span>)
<span class="ruby-identifier">procCertEnumCertificatesInStore</span>                          = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertEnumCertificatesInStore&quot;</span>)
<span class="ruby-identifier">procCertFindCertificateInStore</span>                           = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertFindCertificateInStore&quot;</span>)
<span class="ruby-identifier">procCertFindChainInStore</span>                                 = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertFindChainInStore&quot;</span>)
<span class="ruby-identifier">procCertFindExtension</span>                                    = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertFindExtension&quot;</span>)
<span class="ruby-identifier">procCertFreeCertificateChain</span>                             = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertFreeCertificateChain&quot;</span>)
<span class="ruby-identifier">procCertFreeCertificateContext</span>                           = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertFreeCertificateContext&quot;</span>)
<span class="ruby-identifier">procCertGetCertificateChain</span>                              = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertGetCertificateChain&quot;</span>)
<span class="ruby-identifier">procCertGetNameStringW</span>                                   = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertGetNameStringW&quot;</span>)
<span class="ruby-identifier">procCertOpenStore</span>                                        = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertOpenStore&quot;</span>)
<span class="ruby-identifier">procCertOpenSystemStoreW</span>                                 = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertOpenSystemStoreW&quot;</span>)
<span class="ruby-identifier">procCertVerifyCertificateChainPolicy</span>                     = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CertVerifyCertificateChainPolicy&quot;</span>)
<span class="ruby-identifier">procCryptAcquireCertificatePrivateKey</span>                    = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptAcquireCertificatePrivateKey&quot;</span>)
<span class="ruby-identifier">procCryptDecodeObject</span>                                    = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptDecodeObject&quot;</span>)
<span class="ruby-identifier">procCryptProtectData</span>                                     = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptProtectData&quot;</span>)
<span class="ruby-identifier">procCryptQueryObject</span>                                     = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptQueryObject&quot;</span>)
<span class="ruby-identifier">procCryptUnprotectData</span>                                   = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CryptUnprotectData&quot;</span>)
<span class="ruby-identifier">procPFXImportCertStore</span>                                   = <span class="ruby-identifier">modcrypt32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;PFXImportCertStore&quot;</span>)
<span class="ruby-identifier">procDnsNameCompare_W</span>                                     = <span class="ruby-identifier">moddnsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DnsNameCompare_W&quot;</span>)
<span class="ruby-identifier">procDnsQuery_W</span>                                           = <span class="ruby-identifier">moddnsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DnsQuery_W&quot;</span>)
<span class="ruby-identifier">procDnsRecordListFree</span>                                    = <span class="ruby-identifier">moddnsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DnsRecordListFree&quot;</span>)
<span class="ruby-identifier">procDwmGetWindowAttribute</span>                                = <span class="ruby-identifier">moddwmapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DwmGetWindowAttribute&quot;</span>)
<span class="ruby-identifier">procDwmSetWindowAttribute</span>                                = <span class="ruby-identifier">moddwmapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DwmSetWindowAttribute&quot;</span>)
<span class="ruby-identifier">procGetAdaptersAddresses</span>                                 = <span class="ruby-identifier">modiphlpapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetAdaptersAddresses&quot;</span>)
<span class="ruby-identifier">procGetAdaptersInfo</span>                                      = <span class="ruby-identifier">modiphlpapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetAdaptersInfo&quot;</span>)
<span class="ruby-identifier">procGetBestInterfaceEx</span>                                   = <span class="ruby-identifier">modiphlpapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetBestInterfaceEx&quot;</span>)
<span class="ruby-identifier">procGetIfEntry</span>                                           = <span class="ruby-identifier">modiphlpapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetIfEntry&quot;</span>)
<span class="ruby-identifier">procAssignProcessToJobObject</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;AssignProcessToJobObject&quot;</span>)
<span class="ruby-identifier">procCancelIo</span>                                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CancelIo&quot;</span>)
<span class="ruby-identifier">procCancelIoEx</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CancelIoEx&quot;</span>)
<span class="ruby-identifier">procCloseHandle</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CloseHandle&quot;</span>)
<span class="ruby-identifier">procConnectNamedPipe</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ConnectNamedPipe&quot;</span>)
<span class="ruby-identifier">procCreateDirectoryW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateDirectoryW&quot;</span>)
<span class="ruby-identifier">procCreateEventExW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateEventExW&quot;</span>)
<span class="ruby-identifier">procCreateEventW</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateEventW&quot;</span>)
<span class="ruby-identifier">procCreateFileMappingW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateFileMappingW&quot;</span>)
<span class="ruby-identifier">procCreateFileW</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateFileW&quot;</span>)
<span class="ruby-identifier">procCreateHardLinkW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateHardLinkW&quot;</span>)
<span class="ruby-identifier">procCreateIoCompletionPort</span>                               = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateIoCompletionPort&quot;</span>)
<span class="ruby-identifier">procCreateJobObjectW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateJobObjectW&quot;</span>)
<span class="ruby-identifier">procCreateMutexExW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateMutexExW&quot;</span>)
<span class="ruby-identifier">procCreateMutexW</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateMutexW&quot;</span>)
<span class="ruby-identifier">procCreateNamedPipeW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateNamedPipeW&quot;</span>)
<span class="ruby-identifier">procCreatePipe</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreatePipe&quot;</span>)
<span class="ruby-identifier">procCreateProcessW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateProcessW&quot;</span>)
<span class="ruby-identifier">procCreateSymbolicLinkW</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateSymbolicLinkW&quot;</span>)
<span class="ruby-identifier">procCreateToolhelp32Snapshot</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateToolhelp32Snapshot&quot;</span>)
<span class="ruby-identifier">procDefineDosDeviceW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DefineDosDeviceW&quot;</span>)
<span class="ruby-identifier">procDeleteFileW</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DeleteFileW&quot;</span>)
<span class="ruby-identifier">procDeleteProcThreadAttributeList</span>                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DeleteProcThreadAttributeList&quot;</span>)
<span class="ruby-identifier">procDeleteVolumeMountPointW</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DeleteVolumeMountPointW&quot;</span>)
<span class="ruby-identifier">procDeviceIoControl</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DeviceIoControl&quot;</span>)
<span class="ruby-identifier">procDuplicateHandle</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DuplicateHandle&quot;</span>)
<span class="ruby-identifier">procExitProcess</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ExitProcess&quot;</span>)
<span class="ruby-identifier">procExpandEnvironmentStringsW</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ExpandEnvironmentStringsW&quot;</span>)
<span class="ruby-identifier">procFindClose</span>                                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindClose&quot;</span>)
<span class="ruby-identifier">procFindCloseChangeNotification</span>                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindCloseChangeNotification&quot;</span>)
<span class="ruby-identifier">procFindFirstChangeNotificationW</span>                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindFirstChangeNotificationW&quot;</span>)
<span class="ruby-identifier">procFindFirstFileW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindFirstFileW&quot;</span>)
<span class="ruby-identifier">procFindFirstVolumeMountPointW</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindFirstVolumeMountPointW&quot;</span>)
<span class="ruby-identifier">procFindFirstVolumeW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindFirstVolumeW&quot;</span>)
<span class="ruby-identifier">procFindNextChangeNotification</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindNextChangeNotification&quot;</span>)
<span class="ruby-identifier">procFindNextFileW</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindNextFileW&quot;</span>)
<span class="ruby-identifier">procFindNextVolumeMountPointW</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindNextVolumeMountPointW&quot;</span>)
<span class="ruby-identifier">procFindNextVolumeW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindNextVolumeW&quot;</span>)
<span class="ruby-identifier">procFindResourceW</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindResourceW&quot;</span>)
<span class="ruby-identifier">procFindVolumeClose</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindVolumeClose&quot;</span>)
<span class="ruby-identifier">procFindVolumeMountPointClose</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FindVolumeMountPointClose&quot;</span>)
<span class="ruby-identifier">procFlushFileBuffers</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FlushFileBuffers&quot;</span>)
<span class="ruby-identifier">procFlushViewOfFile</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FlushViewOfFile&quot;</span>)
<span class="ruby-identifier">procFormatMessageW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FormatMessageW&quot;</span>)
<span class="ruby-identifier">procFreeEnvironmentStringsW</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FreeEnvironmentStringsW&quot;</span>)
<span class="ruby-identifier">procFreeLibrary</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FreeLibrary&quot;</span>)
<span class="ruby-identifier">procGenerateConsoleCtrlEvent</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GenerateConsoleCtrlEvent&quot;</span>)
<span class="ruby-identifier">procGetACP</span>                                               = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetACP&quot;</span>)
<span class="ruby-identifier">procGetActiveProcessorCount</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetActiveProcessorCount&quot;</span>)
<span class="ruby-identifier">procGetCommTimeouts</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetCommTimeouts&quot;</span>)
<span class="ruby-identifier">procGetCommandLineW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetCommandLineW&quot;</span>)
<span class="ruby-identifier">procGetComputerNameExW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetComputerNameExW&quot;</span>)
<span class="ruby-identifier">procGetComputerNameW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetComputerNameW&quot;</span>)
<span class="ruby-identifier">procGetConsoleMode</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetConsoleMode&quot;</span>)
<span class="ruby-identifier">procGetConsoleScreenBufferInfo</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetConsoleScreenBufferInfo&quot;</span>)
<span class="ruby-identifier">procGetCurrentDirectoryW</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetCurrentDirectoryW&quot;</span>)
<span class="ruby-identifier">procGetCurrentProcessId</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetCurrentProcessId&quot;</span>)
<span class="ruby-identifier">procGetCurrentThreadId</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetCurrentThreadId&quot;</span>)
<span class="ruby-identifier">procGetDiskFreeSpaceExW</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetDiskFreeSpaceExW&quot;</span>)
<span class="ruby-identifier">procGetDriveTypeW</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetDriveTypeW&quot;</span>)
<span class="ruby-identifier">procGetEnvironmentStringsW</span>                               = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetEnvironmentStringsW&quot;</span>)
<span class="ruby-identifier">procGetEnvironmentVariableW</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetEnvironmentVariableW&quot;</span>)
<span class="ruby-identifier">procGetExitCodeProcess</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetExitCodeProcess&quot;</span>)
<span class="ruby-identifier">procGetFileAttributesExW</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileAttributesExW&quot;</span>)
<span class="ruby-identifier">procGetFileAttributesW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileAttributesW&quot;</span>)
<span class="ruby-identifier">procGetFileInformationByHandle</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileInformationByHandle&quot;</span>)
<span class="ruby-identifier">procGetFileInformationByHandleEx</span>                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileInformationByHandleEx&quot;</span>)
<span class="ruby-identifier">procGetFileType</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileType&quot;</span>)
<span class="ruby-identifier">procGetFinalPathNameByHandleW</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFinalPathNameByHandleW&quot;</span>)
<span class="ruby-identifier">procGetFullPathNameW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFullPathNameW&quot;</span>)
<span class="ruby-identifier">procGetLargePageMinimum</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetLargePageMinimum&quot;</span>)
<span class="ruby-identifier">procGetLastError</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetLastError&quot;</span>)
<span class="ruby-identifier">procGetLogicalDriveStringsW</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetLogicalDriveStringsW&quot;</span>)
<span class="ruby-identifier">procGetLogicalDrives</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetLogicalDrives&quot;</span>)
<span class="ruby-identifier">procGetLongPathNameW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetLongPathNameW&quot;</span>)
<span class="ruby-identifier">procGetMaximumProcessorCount</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetMaximumProcessorCount&quot;</span>)
<span class="ruby-identifier">procGetModuleFileNameW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetModuleFileNameW&quot;</span>)
<span class="ruby-identifier">procGetModuleHandleExW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetModuleHandleExW&quot;</span>)
<span class="ruby-identifier">procGetNamedPipeHandleStateW</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetNamedPipeHandleStateW&quot;</span>)
<span class="ruby-identifier">procGetNamedPipeInfo</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetNamedPipeInfo&quot;</span>)
<span class="ruby-identifier">procGetOverlappedResult</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetOverlappedResult&quot;</span>)
<span class="ruby-identifier">procGetPriorityClass</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetPriorityClass&quot;</span>)
<span class="ruby-identifier">procGetProcAddress</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetProcAddress&quot;</span>)
<span class="ruby-identifier">procGetProcessId</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetProcessId&quot;</span>)
<span class="ruby-identifier">procGetProcessPreferredUILanguages</span>                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetProcessPreferredUILanguages&quot;</span>)
<span class="ruby-identifier">procGetProcessShutdownParameters</span>                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetProcessShutdownParameters&quot;</span>)
<span class="ruby-identifier">procGetProcessTimes</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetProcessTimes&quot;</span>)
<span class="ruby-identifier">procGetProcessWorkingSetSizeEx</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetProcessWorkingSetSizeEx&quot;</span>)
<span class="ruby-identifier">procGetQueuedCompletionStatus</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetQueuedCompletionStatus&quot;</span>)
<span class="ruby-identifier">procGetShortPathNameW</span>                                    = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetShortPathNameW&quot;</span>)
<span class="ruby-identifier">procGetStartupInfoW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetStartupInfoW&quot;</span>)
<span class="ruby-identifier">procGetStdHandle</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetStdHandle&quot;</span>)
<span class="ruby-identifier">procGetSystemDirectoryW</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSystemDirectoryW&quot;</span>)
<span class="ruby-identifier">procGetSystemPreferredUILanguages</span>                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSystemPreferredUILanguages&quot;</span>)
<span class="ruby-identifier">procGetSystemTimeAsFileTime</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSystemTimeAsFileTime&quot;</span>)
<span class="ruby-identifier">procGetSystemTimePreciseAsFileTime</span>                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSystemTimePreciseAsFileTime&quot;</span>)
<span class="ruby-identifier">procGetSystemWindowsDirectoryW</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetSystemWindowsDirectoryW&quot;</span>)
<span class="ruby-identifier">procGetTempPathW</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetTempPathW&quot;</span>)
<span class="ruby-identifier">procGetThreadPreferredUILanguages</span>                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetThreadPreferredUILanguages&quot;</span>)
<span class="ruby-identifier">procGetTickCount64</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetTickCount64&quot;</span>)
<span class="ruby-identifier">procGetTimeZoneInformation</span>                               = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetTimeZoneInformation&quot;</span>)
<span class="ruby-identifier">procGetUserPreferredUILanguages</span>                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetUserPreferredUILanguages&quot;</span>)
<span class="ruby-identifier">procGetVersion</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetVersion&quot;</span>)
<span class="ruby-identifier">procGetVolumeInformationByHandleW</span>                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetVolumeInformationByHandleW&quot;</span>)
<span class="ruby-identifier">procGetVolumeInformationW</span>                                = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetVolumeInformationW&quot;</span>)
<span class="ruby-identifier">procGetVolumeNameForVolumeMountPointW</span>                    = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetVolumeNameForVolumeMountPointW&quot;</span>)
<span class="ruby-identifier">procGetVolumePathNameW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetVolumePathNameW&quot;</span>)
<span class="ruby-identifier">procGetVolumePathNamesForVolumeNameW</span>                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetVolumePathNamesForVolumeNameW&quot;</span>)
<span class="ruby-identifier">procGetWindowsDirectoryW</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetWindowsDirectoryW&quot;</span>)
<span class="ruby-identifier">procInitializeProcThreadAttributeList</span>                    = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;InitializeProcThreadAttributeList&quot;</span>)
<span class="ruby-identifier">procIsWow64Process</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsWow64Process&quot;</span>)
<span class="ruby-identifier">procIsWow64Process2</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsWow64Process2&quot;</span>)
<span class="ruby-identifier">procLoadLibraryExW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LoadLibraryExW&quot;</span>)
<span class="ruby-identifier">procLoadLibraryW</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LoadLibraryW&quot;</span>)
<span class="ruby-identifier">procLoadResource</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LoadResource&quot;</span>)
<span class="ruby-identifier">procLocalAlloc</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LocalAlloc&quot;</span>)
<span class="ruby-identifier">procLocalFree</span>                                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LocalFree&quot;</span>)
<span class="ruby-identifier">procLockFileEx</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LockFileEx&quot;</span>)
<span class="ruby-identifier">procLockResource</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;LockResource&quot;</span>)
<span class="ruby-identifier">procMapViewOfFile</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MapViewOfFile&quot;</span>)
<span class="ruby-identifier">procModule32FirstW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;Module32FirstW&quot;</span>)
<span class="ruby-identifier">procModule32NextW</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;Module32NextW&quot;</span>)
<span class="ruby-identifier">procMoveFileExW</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MoveFileExW&quot;</span>)
<span class="ruby-identifier">procMoveFileW</span>                                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MoveFileW&quot;</span>)
<span class="ruby-identifier">procMultiByteToWideChar</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MultiByteToWideChar&quot;</span>)
<span class="ruby-identifier">procOpenEventW</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenEventW&quot;</span>)
<span class="ruby-identifier">procOpenMutexW</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenMutexW&quot;</span>)
<span class="ruby-identifier">procOpenProcess</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenProcess&quot;</span>)
<span class="ruby-identifier">procOpenThread</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;OpenThread&quot;</span>)
<span class="ruby-identifier">procPostQueuedCompletionStatus</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;PostQueuedCompletionStatus&quot;</span>)
<span class="ruby-identifier">procProcess32FirstW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;Process32FirstW&quot;</span>)
<span class="ruby-identifier">procProcess32NextW</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;Process32NextW&quot;</span>)
<span class="ruby-identifier">procProcessIdToSessionId</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ProcessIdToSessionId&quot;</span>)
<span class="ruby-identifier">procPulseEvent</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;PulseEvent&quot;</span>)
<span class="ruby-identifier">procQueryDosDeviceW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryDosDeviceW&quot;</span>)
<span class="ruby-identifier">procQueryFullProcessImageNameW</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryFullProcessImageNameW&quot;</span>)
<span class="ruby-identifier">procQueryInformationJobObject</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryInformationJobObject&quot;</span>)
<span class="ruby-identifier">procReadConsoleW</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ReadConsoleW&quot;</span>)
<span class="ruby-identifier">procReadDirectoryChangesW</span>                                = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ReadDirectoryChangesW&quot;</span>)
<span class="ruby-identifier">procReadFile</span>                                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ReadFile&quot;</span>)
<span class="ruby-identifier">procReadProcessMemory</span>                                    = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ReadProcessMemory&quot;</span>)
<span class="ruby-identifier">procReleaseMutex</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ReleaseMutex&quot;</span>)
<span class="ruby-identifier">procRemoveDirectoryW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RemoveDirectoryW&quot;</span>)
<span class="ruby-identifier">procResetEvent</span>                                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ResetEvent&quot;</span>)
<span class="ruby-identifier">procResumeThread</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ResumeThread&quot;</span>)
<span class="ruby-identifier">procSetCommTimeouts</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetCommTimeouts&quot;</span>)
<span class="ruby-identifier">procSetConsoleCursorPosition</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetConsoleCursorPosition&quot;</span>)
<span class="ruby-identifier">procSetConsoleMode</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetConsoleMode&quot;</span>)
<span class="ruby-identifier">procSetCurrentDirectoryW</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetCurrentDirectoryW&quot;</span>)
<span class="ruby-identifier">procSetDefaultDllDirectories</span>                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetDefaultDllDirectories&quot;</span>)
<span class="ruby-identifier">procSetDllDirectoryW</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetDllDirectoryW&quot;</span>)
<span class="ruby-identifier">procSetEndOfFile</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetEndOfFile&quot;</span>)
<span class="ruby-identifier">procSetEnvironmentVariableW</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetEnvironmentVariableW&quot;</span>)
<span class="ruby-identifier">procSetErrorMode</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetErrorMode&quot;</span>)
<span class="ruby-identifier">procSetEvent</span>                                             = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetEvent&quot;</span>)
<span class="ruby-identifier">procSetFileAttributesW</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetFileAttributesW&quot;</span>)
<span class="ruby-identifier">procSetFileCompletionNotificationModes</span>                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetFileCompletionNotificationModes&quot;</span>)
<span class="ruby-identifier">procSetFileInformationByHandle</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetFileInformationByHandle&quot;</span>)
<span class="ruby-identifier">procSetFilePointer</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetFilePointer&quot;</span>)
<span class="ruby-identifier">procSetFileTime</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetFileTime&quot;</span>)
<span class="ruby-identifier">procSetHandleInformation</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetHandleInformation&quot;</span>)
<span class="ruby-identifier">procSetInformationJobObject</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetInformationJobObject&quot;</span>)
<span class="ruby-identifier">procSetNamedPipeHandleState</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetNamedPipeHandleState&quot;</span>)
<span class="ruby-identifier">procSetPriorityClass</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetPriorityClass&quot;</span>)
<span class="ruby-identifier">procSetProcessPriorityBoost</span>                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetProcessPriorityBoost&quot;</span>)
<span class="ruby-identifier">procSetProcessShutdownParameters</span>                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetProcessShutdownParameters&quot;</span>)
<span class="ruby-identifier">procSetProcessWorkingSetSizeEx</span>                           = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetProcessWorkingSetSizeEx&quot;</span>)
<span class="ruby-identifier">procSetStdHandle</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetStdHandle&quot;</span>)
<span class="ruby-identifier">procSetVolumeLabelW</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetVolumeLabelW&quot;</span>)
<span class="ruby-identifier">procSetVolumeMountPointW</span>                                 = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetVolumeMountPointW&quot;</span>)
<span class="ruby-identifier">procSizeofResource</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SizeofResource&quot;</span>)
<span class="ruby-identifier">procSleepEx</span>                                              = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SleepEx&quot;</span>)
<span class="ruby-identifier">procTerminateJobObject</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;TerminateJobObject&quot;</span>)
<span class="ruby-identifier">procTerminateProcess</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;TerminateProcess&quot;</span>)
<span class="ruby-identifier">procThread32First</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;Thread32First&quot;</span>)
<span class="ruby-identifier">procThread32Next</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;Thread32Next&quot;</span>)
<span class="ruby-identifier">procUnlockFileEx</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;UnlockFileEx&quot;</span>)
<span class="ruby-identifier">procUnmapViewOfFile</span>                                      = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;UnmapViewOfFile&quot;</span>)
<span class="ruby-identifier">procUpdateProcThreadAttribute</span>                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;UpdateProcThreadAttribute&quot;</span>)
<span class="ruby-identifier">procVirtualAlloc</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualAlloc&quot;</span>)
<span class="ruby-identifier">procVirtualFree</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualFree&quot;</span>)
<span class="ruby-identifier">procVirtualLock</span>                                          = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualLock&quot;</span>)
<span class="ruby-identifier">procVirtualProtect</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualProtect&quot;</span>)
<span class="ruby-identifier">procVirtualProtectEx</span>                                     = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualProtectEx&quot;</span>)
<span class="ruby-identifier">procVirtualQuery</span>                                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualQuery&quot;</span>)
<span class="ruby-identifier">procVirtualQueryEx</span>                                       = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualQueryEx&quot;</span>)
<span class="ruby-identifier">procVirtualUnlock</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VirtualUnlock&quot;</span>)
<span class="ruby-identifier">procWTSGetActiveConsoleSessionId</span>                         = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WTSGetActiveConsoleSessionId&quot;</span>)
<span class="ruby-identifier">procWaitForMultipleObjects</span>                               = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WaitForMultipleObjects&quot;</span>)
<span class="ruby-identifier">procWaitForSingleObject</span>                                  = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WaitForSingleObject&quot;</span>)
<span class="ruby-identifier">procWriteConsoleW</span>                                        = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WriteConsoleW&quot;</span>)
<span class="ruby-identifier">procWriteFile</span>                                            = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WriteFile&quot;</span>)
<span class="ruby-identifier">procWriteProcessMemory</span>                                   = <span class="ruby-identifier">modkernel32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WriteProcessMemory&quot;</span>)
<span class="ruby-identifier">procAcceptEx</span>                                             = <span class="ruby-identifier">modmswsock</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;AcceptEx&quot;</span>)
<span class="ruby-identifier">procGetAcceptExSockaddrs</span>                                 = <span class="ruby-identifier">modmswsock</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetAcceptExSockaddrs&quot;</span>)
<span class="ruby-identifier">procTransmitFile</span>                                         = <span class="ruby-identifier">modmswsock</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;TransmitFile&quot;</span>)
<span class="ruby-identifier">procNetApiBufferFree</span>                                     = <span class="ruby-identifier">modnetapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NetApiBufferFree&quot;</span>)
<span class="ruby-identifier">procNetGetJoinInformation</span>                                = <span class="ruby-identifier">modnetapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NetGetJoinInformation&quot;</span>)
<span class="ruby-identifier">procNetUserGetInfo</span>                                       = <span class="ruby-identifier">modnetapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NetUserGetInfo&quot;</span>)
<span class="ruby-identifier">procNtCreateFile</span>                                         = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtCreateFile&quot;</span>)
<span class="ruby-identifier">procNtCreateNamedPipeFile</span>                                = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtCreateNamedPipeFile&quot;</span>)
<span class="ruby-identifier">procNtQueryInformationProcess</span>                            = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtQueryInformationProcess&quot;</span>)
<span class="ruby-identifier">procNtQuerySystemInformation</span>                             = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtQuerySystemInformation&quot;</span>)
<span class="ruby-identifier">procNtSetInformationFile</span>                                 = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtSetInformationFile&quot;</span>)
<span class="ruby-identifier">procNtSetInformationProcess</span>                              = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtSetInformationProcess&quot;</span>)
<span class="ruby-identifier">procNtSetSystemInformation</span>                               = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;NtSetSystemInformation&quot;</span>)
<span class="ruby-identifier">procRtlAddFunctionTable</span>                                  = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlAddFunctionTable&quot;</span>)
<span class="ruby-identifier">procRtlDefaultNpAcl</span>                                      = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlDefaultNpAcl&quot;</span>)
<span class="ruby-identifier">procRtlDeleteFunctionTable</span>                               = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlDeleteFunctionTable&quot;</span>)
<span class="ruby-identifier">procRtlDosPathNameToNtPathName_U_WithStatus</span>              = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlDosPathNameToNtPathName_U_WithStatus&quot;</span>)
<span class="ruby-identifier">procRtlDosPathNameToRelativeNtPathName_U_WithStatus</span>      = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlDosPathNameToRelativeNtPathName_U_WithStatus&quot;</span>)
<span class="ruby-identifier">procRtlGetCurrentPeb</span>                                     = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlGetCurrentPeb&quot;</span>)
<span class="ruby-identifier">procRtlGetNtVersionNumbers</span>                               = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlGetNtVersionNumbers&quot;</span>)
<span class="ruby-identifier">procRtlGetVersion</span>                                        = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlGetVersion&quot;</span>)
<span class="ruby-identifier">procRtlInitString</span>                                        = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlInitString&quot;</span>)
<span class="ruby-identifier">procRtlInitUnicodeString</span>                                 = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlInitUnicodeString&quot;</span>)
<span class="ruby-identifier">procRtlNtStatusToDosErrorNoTeb</span>                           = <span class="ruby-identifier">modntdll</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;RtlNtStatusToDosErrorNoTeb&quot;</span>)
<span class="ruby-identifier">procCLSIDFromString</span>                                      = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CLSIDFromString&quot;</span>)
<span class="ruby-identifier">procCoCreateGuid</span>                                         = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CoCreateGuid&quot;</span>)
<span class="ruby-identifier">procCoGetObject</span>                                          = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CoGetObject&quot;</span>)
<span class="ruby-identifier">procCoInitializeEx</span>                                       = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CoInitializeEx&quot;</span>)
<span class="ruby-identifier">procCoTaskMemFree</span>                                        = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CoTaskMemFree&quot;</span>)
<span class="ruby-identifier">procCoUninitialize</span>                                       = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CoUninitialize&quot;</span>)
<span class="ruby-identifier">procStringFromGUID2</span>                                      = <span class="ruby-identifier">modole32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;StringFromGUID2&quot;</span>)
<span class="ruby-identifier">procEnumProcessModules</span>                                   = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EnumProcessModules&quot;</span>)
<span class="ruby-identifier">procEnumProcessModulesEx</span>                                 = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EnumProcessModulesEx&quot;</span>)
<span class="ruby-identifier">procEnumProcesses</span>                                        = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EnumProcesses&quot;</span>)
<span class="ruby-identifier">procGetModuleBaseNameW</span>                                   = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetModuleBaseNameW&quot;</span>)
<span class="ruby-identifier">procGetModuleFileNameExW</span>                                 = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetModuleFileNameExW&quot;</span>)
<span class="ruby-identifier">procGetModuleInformation</span>                                 = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetModuleInformation&quot;</span>)
<span class="ruby-identifier">procQueryWorkingSetEx</span>                                    = <span class="ruby-identifier">modpsapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;QueryWorkingSetEx&quot;</span>)
<span class="ruby-identifier">procSubscribeServiceChangeNotifications</span>                  = <span class="ruby-identifier">modsechost</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SubscribeServiceChangeNotifications&quot;</span>)
<span class="ruby-identifier">procUnsubscribeServiceChangeNotifications</span>                = <span class="ruby-identifier">modsechost</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;UnsubscribeServiceChangeNotifications&quot;</span>)
<span class="ruby-identifier">procGetUserNameExW</span>                                       = <span class="ruby-identifier">modsecur32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetUserNameExW&quot;</span>)
<span class="ruby-identifier">procTranslateNameW</span>                                       = <span class="ruby-identifier">modsecur32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;TranslateNameW&quot;</span>)
<span class="ruby-identifier">procSetupDiBuildDriverInfoList</span>                           = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiBuildDriverInfoList&quot;</span>)
<span class="ruby-identifier">procSetupDiCallClassInstaller</span>                            = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiCallClassInstaller&quot;</span>)
<span class="ruby-identifier">procSetupDiCancelDriverInfoSearch</span>                        = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiCancelDriverInfoSearch&quot;</span>)
<span class="ruby-identifier">procSetupDiClassGuidsFromNameExW</span>                         = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiClassGuidsFromNameExW&quot;</span>)
<span class="ruby-identifier">procSetupDiClassNameFromGuidExW</span>                          = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiClassNameFromGuidExW&quot;</span>)
<span class="ruby-identifier">procSetupDiCreateDeviceInfoListExW</span>                       = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiCreateDeviceInfoListExW&quot;</span>)
<span class="ruby-identifier">procSetupDiCreateDeviceInfoW</span>                             = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiCreateDeviceInfoW&quot;</span>)
<span class="ruby-identifier">procSetupDiDestroyDeviceInfoList</span>                         = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiDestroyDeviceInfoList&quot;</span>)
<span class="ruby-identifier">procSetupDiDestroyDriverInfoList</span>                         = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiDestroyDriverInfoList&quot;</span>)
<span class="ruby-identifier">procSetupDiEnumDeviceInfo</span>                                = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiEnumDeviceInfo&quot;</span>)
<span class="ruby-identifier">procSetupDiEnumDriverInfoW</span>                               = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiEnumDriverInfoW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetClassDevsExW</span>                               = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetClassDevsExW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetClassInstallParamsW</span>                        = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetClassInstallParamsW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetDeviceInfoListDetailW</span>                      = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetDeviceInfoListDetailW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetDeviceInstallParamsW</span>                       = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetDeviceInstallParamsW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetDeviceInstanceIdW</span>                          = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetDeviceInstanceIdW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetDevicePropertyW</span>                            = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetDevicePropertyW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetDeviceRegistryPropertyW</span>                    = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetDeviceRegistryPropertyW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetDriverInfoDetailW</span>                          = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetDriverInfoDetailW&quot;</span>)
<span class="ruby-identifier">procSetupDiGetSelectedDevice</span>                             = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetSelectedDevice&quot;</span>)
<span class="ruby-identifier">procSetupDiGetSelectedDriverW</span>                            = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiGetSelectedDriverW&quot;</span>)
<span class="ruby-identifier">procSetupDiOpenDevRegKey</span>                                 = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiOpenDevRegKey&quot;</span>)
<span class="ruby-identifier">procSetupDiSetClassInstallParamsW</span>                        = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiSetClassInstallParamsW&quot;</span>)
<span class="ruby-identifier">procSetupDiSetDeviceInstallParamsW</span>                       = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiSetDeviceInstallParamsW&quot;</span>)
<span class="ruby-identifier">procSetupDiSetDeviceRegistryPropertyW</span>                    = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiSetDeviceRegistryPropertyW&quot;</span>)
<span class="ruby-identifier">procSetupDiSetSelectedDevice</span>                             = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiSetSelectedDevice&quot;</span>)
<span class="ruby-identifier">procSetupDiSetSelectedDriverW</span>                            = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupDiSetSelectedDriverW&quot;</span>)
<span class="ruby-identifier">procSetupUninstallOEMInfW</span>                                = <span class="ruby-identifier">modsetupapi</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SetupUninstallOEMInfW&quot;</span>)
<span class="ruby-identifier">procCommandLineToArgvW</span>                                   = <span class="ruby-identifier">modshell32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CommandLineToArgvW&quot;</span>)
<span class="ruby-identifier">procSHGetKnownFolderPath</span>                                 = <span class="ruby-identifier">modshell32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;SHGetKnownFolderPath&quot;</span>)
<span class="ruby-identifier">procShellExecuteW</span>                                        = <span class="ruby-identifier">modshell32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ShellExecuteW&quot;</span>)
<span class="ruby-identifier">procEnumChildWindows</span>                                     = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EnumChildWindows&quot;</span>)
<span class="ruby-identifier">procEnumWindows</span>                                          = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;EnumWindows&quot;</span>)
<span class="ruby-identifier">procExitWindowsEx</span>                                        = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ExitWindowsEx&quot;</span>)
<span class="ruby-identifier">procGetClassNameW</span>                                        = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetClassNameW&quot;</span>)
<span class="ruby-identifier">procGetDesktopWindow</span>                                     = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetDesktopWindow&quot;</span>)
<span class="ruby-identifier">procGetForegroundWindow</span>                                  = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetForegroundWindow&quot;</span>)
<span class="ruby-identifier">procGetGUIThreadInfo</span>                                     = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetGUIThreadInfo&quot;</span>)
<span class="ruby-identifier">procGetShellWindow</span>                                       = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetShellWindow&quot;</span>)
<span class="ruby-identifier">procGetWindowThreadProcessId</span>                             = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetWindowThreadProcessId&quot;</span>)
<span class="ruby-identifier">procIsWindow</span>                                             = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsWindow&quot;</span>)
<span class="ruby-identifier">procIsWindowUnicode</span>                                      = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsWindowUnicode&quot;</span>)
<span class="ruby-identifier">procIsWindowVisible</span>                                      = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;IsWindowVisible&quot;</span>)
<span class="ruby-identifier">procMessageBoxW</span>                                          = <span class="ruby-identifier">moduser32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;MessageBoxW&quot;</span>)
<span class="ruby-identifier">procCreateEnvironmentBlock</span>                               = <span class="ruby-identifier">moduserenv</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;CreateEnvironmentBlock&quot;</span>)
<span class="ruby-identifier">procDestroyEnvironmentBlock</span>                              = <span class="ruby-identifier">moduserenv</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;DestroyEnvironmentBlock&quot;</span>)
<span class="ruby-identifier">procGetUserProfileDirectoryW</span>                             = <span class="ruby-identifier">moduserenv</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetUserProfileDirectoryW&quot;</span>)
<span class="ruby-identifier">procGetFileVersionInfoSizeW</span>                              = <span class="ruby-identifier">modversion</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileVersionInfoSizeW&quot;</span>)
<span class="ruby-identifier">procGetFileVersionInfoW</span>                                  = <span class="ruby-identifier">modversion</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetFileVersionInfoW&quot;</span>)
<span class="ruby-identifier">procVerQueryValueW</span>                                       = <span class="ruby-identifier">modversion</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;VerQueryValueW&quot;</span>)
<span class="ruby-identifier">procWinVerifyTrustEx</span>                                     = <span class="ruby-identifier">modwintrust</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WinVerifyTrustEx&quot;</span>)
<span class="ruby-identifier">procFreeAddrInfoW</span>                                        = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;FreeAddrInfoW&quot;</span>)
<span class="ruby-identifier">procGetAddrInfoW</span>                                         = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;GetAddrInfoW&quot;</span>)
<span class="ruby-identifier">procWSACleanup</span>                                           = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSACleanup&quot;</span>)
<span class="ruby-identifier">procWSAEnumProtocolsW</span>                                    = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSAEnumProtocolsW&quot;</span>)
<span class="ruby-identifier">procWSAGetOverlappedResult</span>                               = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSAGetOverlappedResult&quot;</span>)
<span class="ruby-identifier">procWSAIoctl</span>                                             = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSAIoctl&quot;</span>)
<span class="ruby-identifier">procWSARecv</span>                                              = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSARecv&quot;</span>)
<span class="ruby-identifier">procWSARecvFrom</span>                                          = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSARecvFrom&quot;</span>)
<span class="ruby-identifier">procWSASend</span>                                              = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSASend&quot;</span>)
<span class="ruby-identifier">procWSASendTo</span>                                            = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSASendTo&quot;</span>)
<span class="ruby-identifier">procWSASocketW</span>                                           = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSASocketW&quot;</span>)
<span class="ruby-identifier">procWSAStartup</span>                                           = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WSAStartup&quot;</span>)
<span class="ruby-identifier">procbind</span>                                                 = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;bind&quot;</span>)
<span class="ruby-identifier">procclosesocket</span>                                          = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;closesocket&quot;</span>)
<span class="ruby-identifier">procconnect</span>                                              = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;connect&quot;</span>)
<span class="ruby-identifier">procgethostbyname</span>                                        = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;gethostbyname&quot;</span>)
<span class="ruby-identifier">procgetpeername</span>                                          = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;getpeername&quot;</span>)
<span class="ruby-identifier">procgetprotobyname</span>                                       = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;getprotobyname&quot;</span>)
<span class="ruby-identifier">procgetservbyname</span>                                        = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;getservbyname&quot;</span>)
<span class="ruby-identifier">procgetsockname</span>                                          = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;getsockname&quot;</span>)
<span class="ruby-identifier">procgetsockopt</span>                                           = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;getsockopt&quot;</span>)
<span class="ruby-identifier">proclisten</span>                                               = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;listen&quot;</span>)
<span class="ruby-identifier">procntohs</span>                                                = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;ntohs&quot;</span>)
<span class="ruby-identifier">procrecvfrom</span>                                             = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;recvfrom&quot;</span>)
<span class="ruby-identifier">procsendto</span>                                               = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;sendto&quot;</span>)
<span class="ruby-identifier">procsetsockopt</span>                                           = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;setsockopt&quot;</span>)
<span class="ruby-identifier">procshutdown</span>                                             = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;shutdown&quot;</span>)
<span class="ruby-identifier">procsocket</span>                                               = <span class="ruby-identifier">modws2_32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;socket&quot;</span>)
<span class="ruby-identifier">procWTSEnumerateSessionsW</span>                                = <span class="ruby-identifier">modwtsapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WTSEnumerateSessionsW&quot;</span>)
<span class="ruby-identifier">procWTSFreeMemory</span>                                        = <span class="ruby-identifier">modwtsapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WTSFreeMemory&quot;</span>)
<span class="ruby-identifier">procWTSQueryUserToken</span>                                    = <span class="ruby-identifier">modwtsapi32</span>.<span class="ruby-constant">NewProc</span>(<span class="ruby-string">&quot;WTSQueryUserToken&quot;</span>)
</pre>

<p>)</p>

<p>func cm_Get_DevNode_Status(status *uint32, problemNumber *uint32, devInst DEVINST, flags uint32) (ret CONFIGRET) {</p>

<pre>r0, _, _ := syscall.Syscall6(procCM_Get_DevNode_Status.Addr(), 4, uintptr(unsafe.Pointer(status)), uintptr(unsafe.Pointer(problemNumber)), uintptr(devInst), uintptr(flags), 0, 0)
ret = CONFIGRET(r0)
return</pre>

<p>}</p>

<p>func cm_Get_Device_Interface_List(interfaceClass *GUID, deviceID *uint16, buffer *uint16, bufferLen uint32, flags uint32) (ret CONFIGRET) {</p>

<pre>r0, _, _ := syscall.Syscall6(procCM_Get_Device_Interface_ListW.Addr(), 5, uintptr(unsafe.Pointer(interfaceClass)), uintptr(unsafe.Pointer(deviceID)), uintptr(unsafe.Pointer(buffer)), uintptr(bufferLen), uintptr(flags), 0)
ret = CONFIGRET(r0)
return</pre>

<p>}</p>

<p>func cm_Get_Device_Interface_List_Size(len *uint32, interfaceClass *GUID, deviceID *uint16, flags uint32) (ret CONFIGRET) {</p>

<pre>r0, _, _ := syscall.Syscall6(procCM_Get_Device_Interface_List_SizeW.Addr(), 4, uintptr(unsafe.Pointer(len)), uintptr(unsafe.Pointer(interfaceClass)), uintptr(unsafe.Pointer(deviceID)), uintptr(flags), 0, 0)
ret = CONFIGRET(r0)
return</pre>

<p>}</p>

<p>func cm_MapCrToWin32Err(configRet CONFIGRET, defaultWin32Error Errno) (ret Errno) {</p>

<pre>r0, _, _ := syscall.Syscall(procCM_MapCrToWin32Err.Addr(), 2, uintptr(configRet), uintptr(defaultWin32Error), 0)
ret = Errno(r0)
return</pre>

<p>}</p>

<p>func AdjustTokenGroups(token Token, resetToDefault bool, newstate *Tokengroups, buflen uint32, prevstate *Tokengroups, returnlen *uint32) (err error) {</p>

<pre>var _p0 uint32
if resetToDefault {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall6(procAdjustTokenGroups.Addr(), 6, uintptr(token), uintptr(_p0), uintptr(unsafe.Pointer(newstate)), uintptr(buflen), uintptr(unsafe.Pointer(prevstate)), uintptr(unsafe.Pointer(returnlen)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func AdjustTokenPrivileges(token Token, disableAllPrivileges bool, newstate *Tokenprivileges, buflen uint32, prevstate *Tokenprivileges, returnlen *uint32) (err error) {</p>

<pre>var _p0 uint32
if disableAllPrivileges {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall6(procAdjustTokenPrivileges.Addr(), 6, uintptr(token), uintptr(_p0), uintptr(unsafe.Pointer(newstate)), uintptr(buflen), uintptr(unsafe.Pointer(prevstate)), uintptr(unsafe.Pointer(returnlen)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func AllocateAndInitializeSid(identAuth *SidIdentifierAuthority, subAuth byte, subAuth0 uint32, subAuth1 uint32, subAuth2 uint32, subAuth3 uint32, subAuth4 uint32, subAuth5 uint32, subAuth6 uint32, subAuth7 uint32, sid **SID) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall12(procAllocateAndInitializeSid.Addr(), 11, uintptr(unsafe.Pointer(identAuth)), uintptr(subAuth), uintptr(subAuth0), uintptr(subAuth1), uintptr(subAuth2), uintptr(subAuth3), uintptr(subAuth4), uintptr(subAuth5), uintptr(subAuth6), uintptr(subAuth7), uintptr(unsafe.Pointer(sid)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func buildSecurityDescriptor(owner *TRUSTEE, group *TRUSTEE, countAccessEntries uint32, accessEntries *EXPLICIT_ACCESS, countAuditEntries uint32, auditEntries *EXPLICIT_ACCESS, oldSecurityDescriptor *SECURITY_DESCRIPTOR, sizeNewSecurityDescriptor *uint32, newSecurityDescriptor **SECURITY_DESCRIPTOR) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall9(procBuildSecurityDescriptorW.Addr(), 9, uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(countAccessEntries), uintptr(unsafe.Pointer(accessEntries)), uintptr(countAuditEntries), uintptr(unsafe.Pointer(auditEntries)), uintptr(unsafe.Pointer(oldSecurityDescriptor)), uintptr(unsafe.Pointer(sizeNewSecurityDescriptor)), uintptr(unsafe.Pointer(newSecurityDescriptor)))
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func ChangeServiceConfig2(service Handle, infoLevel uint32, info *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procChangeServiceConfig2W.Addr(), 3, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(info)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ChangeServiceConfig(service Handle, serviceType uint32, startType uint32, errorControl uint32, binaryPathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16, displayName *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall12(procChangeServiceConfigW.Addr(), 11, uintptr(service), uintptr(serviceType), uintptr(startType), uintptr(errorControl), uintptr(unsafe.Pointer(binaryPathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), uintptr(unsafe.Pointer(displayName)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func checkTokenMembership(tokenHandle Token, sidToCheck *SID, isMember *int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCheckTokenMembership.Addr(), 3, uintptr(tokenHandle), uintptr(unsafe.Pointer(sidToCheck)), uintptr(unsafe.Pointer(isMember)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CloseServiceHandle(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCloseServiceHandle.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ControlService(service Handle, control uint32, status *SERVICE_STATUS) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procControlService.Addr(), 3, uintptr(service), uintptr(control), uintptr(unsafe.Pointer(status)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func convertSecurityDescriptorToStringSecurityDescriptor(sd *SECURITY_DESCRIPTOR, revision uint32, securityInformation SECURITY_INFORMATION, str **uint16, strLen *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procConvertSecurityDescriptorToStringSecurityDescriptorW.Addr(), 5, uintptr(unsafe.Pointer(sd)), uintptr(revision), uintptr(securityInformation), uintptr(unsafe.Pointer(str)), uintptr(unsafe.Pointer(strLen)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ConvertSidToStringSid(sid *SID, stringSid **uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procConvertSidToStringSidW.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(stringSid)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func convertStringSecurityDescriptorToSecurityDescriptor(str string, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(str)
if err != nil {
        return
}
return _convertStringSecurityDescriptorToSecurityDescriptor(_p0, revision, sd, size)</pre>

<p>}</p>

<p>func _convertStringSecurityDescriptorToSecurityDescriptor(str *uint16, revision uint32, sd **SECURITY_DESCRIPTOR, size *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procConvertStringSecurityDescriptorToSecurityDescriptorW.Addr(), 4, uintptr(unsafe.Pointer(str)), uintptr(revision), uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(size)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ConvertStringSidToSid(stringSid *uint16, sid **SID) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procConvertStringSidToSidW.Addr(), 2, uintptr(unsafe.Pointer(stringSid)), uintptr(unsafe.Pointer(sid)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CopySid(destSidLen uint32, destSid *SID, srcSid *SID) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCopySid.Addr(), 3, uintptr(destSidLen), uintptr(unsafe.Pointer(destSid)), uintptr(unsafe.Pointer(srcSid)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateProcessAsUser(token Token, appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) {</p>

<pre>var _p0 uint32
if inheritHandles {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall12(procCreateProcessAsUserW.Addr(), 11, uintptr(token), uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateService(mgr Handle, serviceName *uint16, displayName *uint16, access uint32, srvType uint32, startType uint32, errCtl uint32, pathName *uint16, loadOrderGroup *uint16, tagId *uint32, dependencies *uint16, serviceStartName *uint16, password *uint16) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall15(procCreateServiceW.Addr(), 13, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(unsafe.Pointer(displayName)), uintptr(access), uintptr(srvType), uintptr(startType), uintptr(errCtl), uintptr(unsafe.Pointer(pathName)), uintptr(unsafe.Pointer(loadOrderGroup)), uintptr(unsafe.Pointer(tagId)), uintptr(unsafe.Pointer(dependencies)), uintptr(unsafe.Pointer(serviceStartName)), uintptr(unsafe.Pointer(password)), 0, 0)
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func createWellKnownSid(sidType WELL_KNOWN_SID_TYPE, domainSid *SID, sid *SID, sizeSid *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procCreateWellKnownSid.Addr(), 4, uintptr(sidType), uintptr(unsafe.Pointer(domainSid)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sizeSid)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptAcquireContext(provhandle *Handle, container *uint16, provider *uint16, provtype uint32, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procCryptAcquireContextW.Addr(), 5, uintptr(unsafe.Pointer(provhandle)), uintptr(unsafe.Pointer(container)), uintptr(unsafe.Pointer(provider)), uintptr(provtype), uintptr(flags), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptGenRandom(provhandle Handle, buflen uint32, buf *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCryptGenRandom.Addr(), 3, uintptr(provhandle), uintptr(buflen), uintptr(unsafe.Pointer(buf)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptReleaseContext(provhandle Handle, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCryptReleaseContext.Addr(), 2, uintptr(provhandle), uintptr(flags), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DeleteService(service Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procDeleteService.Addr(), 1, uintptr(service), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DeregisterEventSource(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procDeregisterEventSource.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DuplicateTokenEx(existingToken Token, desiredAccess uint32, tokenAttributes *SecurityAttributes, impersonationLevel uint32, tokenType uint32, newToken *Token) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procDuplicateTokenEx.Addr(), 6, uintptr(existingToken), uintptr(desiredAccess), uintptr(unsafe.Pointer(tokenAttributes)), uintptr(impersonationLevel), uintptr(tokenType), uintptr(unsafe.Pointer(newToken)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func EnumServicesStatusEx(mgr Handle, infoLevel uint32, serviceType uint32, serviceState uint32, services *byte, bufSize uint32, bytesNeeded *uint32, servicesReturned *uint32, resumeHandle *uint32, groupName *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall12(procEnumServicesStatusExW.Addr(), 10, uintptr(mgr), uintptr(infoLevel), uintptr(serviceType), uintptr(serviceState), uintptr(unsafe.Pointer(services)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), uintptr(unsafe.Pointer(servicesReturned)), uintptr(unsafe.Pointer(resumeHandle)), uintptr(unsafe.Pointer(groupName)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func EqualSid(sid1 *SID, sid2 *SID) (isEqual bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procEqualSid.Addr(), 2, uintptr(unsafe.Pointer(sid1)), uintptr(unsafe.Pointer(sid2)), 0)
isEqual = r0 != 0
return</pre>

<p>}</p>

<p>func FreeSid(sid *SID) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFreeSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
if r1 != 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetLengthSid(sid *SID) (len uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetLengthSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
len = uint32(r0)
return</pre>

<p>}</p>

<p>func getNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) {</p>

<pre>var _p0 *uint16
_p0, ret = syscall.UTF16PtrFromString(objectName)
if ret != nil {
        return
}
return _getNamedSecurityInfo(_p0, objectType, securityInformation, owner, group, dacl, sacl, sd)</pre>

<p>}</p>

<p>func _getNamedSecurityInfo(objectName *uint16, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall9(procGetNamedSecurityInfoW.Addr(), 8, uintptr(unsafe.Pointer(objectName)), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(sd)), 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func getSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, control *SECURITY_DESCRIPTOR_CONTROL, revision *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetSecurityDescriptorControl.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(control)), uintptr(unsafe.Pointer(revision)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent *bool, dacl **ACL, daclDefaulted *bool) (err error) {</p>

<pre>var _p0 uint32
if *daclPresent {
        _p0 = 1
}
var _p1 uint32
if *daclDefaulted {
        _p1 = 1
}
r1, _, e1 := syscall.Syscall6(procGetSecurityDescriptorDacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(&amp;_p0)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(&amp;_p1)), 0, 0)
*daclPresent = _p0 != 0
*daclDefaulted = _p1 != 0
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group **SID, groupDefaulted *bool) (err error) {</p>

<pre>var _p0 uint32
if *groupDefaulted {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procGetSecurityDescriptorGroup.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(&amp;_p0)))
*groupDefaulted = _p0 != 0
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSecurityDescriptorLength(sd *SECURITY_DESCRIPTOR) (len uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetSecurityDescriptorLength.Addr(), 1, uintptr(unsafe.Pointer(sd)), 0, 0)
len = uint32(r0)
return</pre>

<p>}</p>

<p>func getSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner **SID, ownerDefaulted *bool) (err error) {</p>

<pre>var _p0 uint32
if *ownerDefaulted {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procGetSecurityDescriptorOwner.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(&amp;_p0)))
*ownerDefaulted = _p0 != 0
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSecurityDescriptorRMControl(sd *SECURITY_DESCRIPTOR, rmControl *uint8) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetSecurityDescriptorRMControl.Addr(), 2, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(rmControl)), 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func getSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent *bool, sacl **ACL, saclDefaulted *bool) (err error) {</p>

<pre>var _p0 uint32
if *saclPresent {
        _p0 = 1
}
var _p1 uint32
if *saclDefaulted {
        _p1 = 1
}
r1, _, e1 := syscall.Syscall6(procGetSecurityDescriptorSacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(&amp;_p0)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(&amp;_p1)), 0, 0)
*saclPresent = _p0 != 0
*saclDefaulted = _p1 != 0
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner **SID, group **SID, dacl **ACL, sacl **ACL, sd **SECURITY_DESCRIPTOR) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall9(procGetSecurityInfo.Addr(), 8, uintptr(handle), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(sd)), 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func getSidIdentifierAuthority(sid *SID) (authority *SidIdentifierAuthority) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetSidIdentifierAuthority.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
authority = (*SidIdentifierAuthority)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func getSidSubAuthority(sid *SID, index uint32) (subAuthority *uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetSidSubAuthority.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(index), 0)
subAuthority = (*uint32)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func getSidSubAuthorityCount(sid *SID) (count *uint8) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetSidSubAuthorityCount.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
count = (*uint8)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func GetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32, returnedLen *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetTokenInformation.Addr(), 5, uintptr(token), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), uintptr(unsafe.Pointer(returnedLen)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ImpersonateSelf(impersonationlevel uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procImpersonateSelf.Addr(), 1, uintptr(impersonationlevel), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func initializeSecurityDescriptor(absoluteSD *SECURITY_DESCRIPTOR, revision uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procInitializeSecurityDescriptor.Addr(), 2, uintptr(unsafe.Pointer(absoluteSD)), uintptr(revision), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func InitiateSystemShutdownEx(machineName *uint16, message *uint16, timeout uint32, forceAppsClosed bool, rebootAfterShutdown bool, reason uint32) (err error) {</p>

<pre>var _p0 uint32
if forceAppsClosed {
        _p0 = 1
}
var _p1 uint32
if rebootAfterShutdown {
        _p1 = 1
}
r1, _, e1 := syscall.Syscall6(procInitiateSystemShutdownExW.Addr(), 6, uintptr(unsafe.Pointer(machineName)), uintptr(unsafe.Pointer(message)), uintptr(timeout), uintptr(_p0), uintptr(_p1), uintptr(reason))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func isTokenRestricted(tokenHandle Token) (ret bool, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procIsTokenRestricted.Addr(), 1, uintptr(tokenHandle), 0, 0)
ret = r0 != 0
if !ret {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func isValidSecurityDescriptor(sd *SECURITY_DESCRIPTOR) (isValid bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procIsValidSecurityDescriptor.Addr(), 1, uintptr(unsafe.Pointer(sd)), 0, 0)
isValid = r0 != 0
return</pre>

<p>}</p>

<p>func isValidSid(sid *SID) (isValid bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procIsValidSid.Addr(), 1, uintptr(unsafe.Pointer(sid)), 0, 0)
isValid = r0 != 0
return</pre>

<p>}</p>

<p>func isWellKnownSid(sid *SID, sidType WELL_KNOWN_SID_TYPE) (isWellKnown bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procIsWellKnownSid.Addr(), 2, uintptr(unsafe.Pointer(sid)), uintptr(sidType), 0)
isWellKnown = r0 != 0
return</pre>

<p>}</p>

<p>func LookupAccountName(systemName *uint16, accountName *uint16, sid *SID, sidLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procLookupAccountNameW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(accountName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(sidLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LookupAccountSid(systemName *uint16, sid *SID, name *uint16, nameLen *uint32, refdDomainName *uint16, refdDomainNameLen *uint32, use *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procLookupAccountSidW.Addr(), 7, uintptr(unsafe.Pointer(systemName)), uintptr(unsafe.Pointer(sid)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(refdDomainName)), uintptr(unsafe.Pointer(refdDomainNameLen)), uintptr(unsafe.Pointer(use)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LookupPrivilegeValue(systemname *uint16, name *uint16, luid *LUID) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procLookupPrivilegeValueW.Addr(), 3, uintptr(unsafe.Pointer(systemname)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(luid)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func makeAbsoluteSD(selfRelativeSD *SECURITY_DESCRIPTOR, absoluteSD *SECURITY_DESCRIPTOR, absoluteSDSize *uint32, dacl *ACL, daclSize *uint32, sacl *ACL, saclSize *uint32, owner *SID, ownerSize *uint32, group *SID, groupSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall12(procMakeAbsoluteSD.Addr(), 11, uintptr(unsafe.Pointer(selfRelativeSD)), uintptr(unsafe.Pointer(absoluteSD)), uintptr(unsafe.Pointer(absoluteSDSize)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(daclSize)), uintptr(unsafe.Pointer(sacl)), uintptr(unsafe.Pointer(saclSize)), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(ownerSize)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(groupSize)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func makeSelfRelativeSD(absoluteSD *SECURITY_DESCRIPTOR, selfRelativeSD *SECURITY_DESCRIPTOR, selfRelativeSDSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procMakeSelfRelativeSD.Addr(), 3, uintptr(unsafe.Pointer(absoluteSD)), uintptr(unsafe.Pointer(selfRelativeSD)), uintptr(unsafe.Pointer(selfRelativeSDSize)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func NotifyServiceStatusChange(service Handle, notifyMask uint32, notifier *SERVICE_NOTIFY) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall(procNotifyServiceStatusChangeW.Addr(), 3, uintptr(service), uintptr(notifyMask), uintptr(unsafe.Pointer(notifier)))
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func OpenProcessToken(process Handle, access uint32, token *Token) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procOpenProcessToken.Addr(), 3, uintptr(process), uintptr(access), uintptr(unsafe.Pointer(token)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenSCManager(machineName *uint16, databaseName *uint16, access uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procOpenSCManagerW.Addr(), 3, uintptr(unsafe.Pointer(machineName)), uintptr(unsafe.Pointer(databaseName)), uintptr(access))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenService(mgr Handle, serviceName *uint16, access uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procOpenServiceW.Addr(), 3, uintptr(mgr), uintptr(unsafe.Pointer(serviceName)), uintptr(access))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenThreadToken(thread Handle, access uint32, openAsSelf bool, token *Token) (err error) {</p>

<pre>var _p0 uint32
if openAsSelf {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall6(procOpenThreadToken.Addr(), 4, uintptr(thread), uintptr(access), uintptr(_p0), uintptr(unsafe.Pointer(token)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryServiceConfig2(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procQueryServiceConfig2W.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryServiceConfig(service Handle, serviceConfig *QUERY_SERVICE_CONFIG, bufSize uint32, bytesNeeded *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procQueryServiceConfigW.Addr(), 4, uintptr(service), uintptr(unsafe.Pointer(serviceConfig)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryServiceDynamicInformation(service Handle, infoLevel uint32, dynamicInfo unsafe.Pointer) (err error) {</p>

<pre>err = procQueryServiceDynamicInformation.Find()
if err != nil {
        return
}
r1, _, e1 := syscall.Syscall(procQueryServiceDynamicInformation.Addr(), 3, uintptr(service), uintptr(infoLevel), uintptr(dynamicInfo))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryServiceLockStatus(mgr Handle, lockStatus *QUERY_SERVICE_LOCK_STATUS, bufSize uint32, bytesNeeded *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procQueryServiceLockStatusW.Addr(), 4, uintptr(mgr), uintptr(unsafe.Pointer(lockStatus)), uintptr(bufSize), uintptr(unsafe.Pointer(bytesNeeded)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryServiceStatus(service Handle, status *SERVICE_STATUS) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procQueryServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(status)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryServiceStatusEx(service Handle, infoLevel uint32, buff *byte, buffSize uint32, bytesNeeded *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procQueryServiceStatusEx.Addr(), 5, uintptr(service), uintptr(infoLevel), uintptr(unsafe.Pointer(buff)), uintptr(buffSize), uintptr(unsafe.Pointer(bytesNeeded)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func RegCloseKey(key Handle) (regerrno error) {</p>

<pre>r0, _, _ := syscall.Syscall(procRegCloseKey.Addr(), 1, uintptr(key), 0, 0)
if r0 != 0 {
        regerrno = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func RegEnumKeyEx(key Handle, index uint32, name *uint16, nameLen *uint32, reserved *uint32, class *uint16, classLen *uint32, lastWriteTime *Filetime) (regerrno error) {</p>

<pre>r0, _, _ := syscall.Syscall9(procRegEnumKeyExW.Addr(), 8, uintptr(key), uintptr(index), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(nameLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(lastWriteTime)), 0)
if r0 != 0 {
        regerrno = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func RegNotifyChangeKeyValue(key Handle, watchSubtree bool, notifyFilter uint32, event Handle, asynchronous bool) (regerrno error) {</p>

<pre>var _p0 uint32
if watchSubtree {
        _p0 = 1
}
var _p1 uint32
if asynchronous {
        _p1 = 1
}
r0, _, _ := syscall.Syscall6(procRegNotifyChangeKeyValue.Addr(), 5, uintptr(key), uintptr(_p0), uintptr(notifyFilter), uintptr(event), uintptr(_p1), 0)
if r0 != 0 {
        regerrno = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func RegOpenKeyEx(key Handle, subkey *uint16, options uint32, desiredAccess uint32, result *Handle) (regerrno error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procRegOpenKeyExW.Addr(), 5, uintptr(key), uintptr(unsafe.Pointer(subkey)), uintptr(options), uintptr(desiredAccess), uintptr(unsafe.Pointer(result)), 0)
if r0 != 0 {
        regerrno = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func RegQueryInfoKey(key Handle, class *uint16, classLen *uint32, reserved *uint32, subkeysLen *uint32, maxSubkeyLen *uint32, maxClassLen *uint32, valuesLen *uint32, maxValueNameLen *uint32, maxValueLen *uint32, saLen *uint32, lastWriteTime *Filetime) (regerrno error) {</p>

<pre>r0, _, _ := syscall.Syscall12(procRegQueryInfoKeyW.Addr(), 12, uintptr(key), uintptr(unsafe.Pointer(class)), uintptr(unsafe.Pointer(classLen)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(subkeysLen)), uintptr(unsafe.Pointer(maxSubkeyLen)), uintptr(unsafe.Pointer(maxClassLen)), uintptr(unsafe.Pointer(valuesLen)), uintptr(unsafe.Pointer(maxValueNameLen)), uintptr(unsafe.Pointer(maxValueLen)), uintptr(unsafe.Pointer(saLen)), uintptr(unsafe.Pointer(lastWriteTime)))
if r0 != 0 {
        regerrno = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func RegQueryValueEx(key Handle, name *uint16, reserved *uint32, valtype *uint32, buf *byte, buflen *uint32) (regerrno error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procRegQueryValueExW.Addr(), 6, uintptr(key), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(reserved)), uintptr(unsafe.Pointer(valtype)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(buflen)))
if r0 != 0 {
        regerrno = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func RegisterEventSource(uncServerName *uint16, sourceName *uint16) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procRegisterEventSourceW.Addr(), 2, uintptr(unsafe.Pointer(uncServerName)), uintptr(unsafe.Pointer(sourceName)), 0)
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func RegisterServiceCtrlHandlerEx(serviceName *uint16, handlerProc uintptr, context uintptr) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procRegisterServiceCtrlHandlerExW.Addr(), 3, uintptr(unsafe.Pointer(serviceName)), uintptr(handlerProc), uintptr(context))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ReportEvent(log Handle, etype uint16, category uint16, eventId uint32, usrSId uintptr, numStrings uint16, dataSize uint32, strings **uint16, rawData *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procReportEventW.Addr(), 9, uintptr(log), uintptr(etype), uintptr(category), uintptr(eventId), uintptr(usrSId), uintptr(numStrings), uintptr(dataSize), uintptr(unsafe.Pointer(strings)), uintptr(unsafe.Pointer(rawData)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func RevertToSelf() (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procRevertToSelf.Addr(), 0, 0, 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setEntriesInAcl(countExplicitEntries uint32, explicitEntries *EXPLICIT_ACCESS, oldACL *ACL, newACL **ACL) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procSetEntriesInAclW.Addr(), 4, uintptr(countExplicitEntries), uintptr(unsafe.Pointer(explicitEntries)), uintptr(unsafe.Pointer(oldACL)), uintptr(unsafe.Pointer(newACL)), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func SetKernelObjectSecurity(handle Handle, securityInformation SECURITY_INFORMATION, securityDescriptor *SECURITY_DESCRIPTOR) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetKernelObjectSecurity.Addr(), 3, uintptr(handle), uintptr(securityInformation), uintptr(unsafe.Pointer(securityDescriptor)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetNamedSecurityInfo(objectName string, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) {</p>

<pre>var _p0 *uint16
_p0, ret = syscall.UTF16PtrFromString(objectName)
if ret != nil {
        return
}
return _SetNamedSecurityInfo(_p0, objectType, securityInformation, owner, group, dacl, sacl)</pre>

<p>}</p>

<p>func _SetNamedSecurityInfo(objectName *uint16, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall9(procSetNamedSecurityInfoW.Addr(), 7, uintptr(unsafe.Pointer(objectName)), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func setSecurityDescriptorControl(sd *SECURITY_DESCRIPTOR, controlBitsOfInterest SECURITY_DESCRIPTOR_CONTROL, controlBitsToSet SECURITY_DESCRIPTOR_CONTROL) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetSecurityDescriptorControl.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(controlBitsOfInterest), uintptr(controlBitsToSet))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setSecurityDescriptorDacl(sd *SECURITY_DESCRIPTOR, daclPresent bool, dacl *ACL, daclDefaulted bool) (err error) {</p>

<pre>var _p0 uint32
if daclPresent {
        _p0 = 1
}
var _p1 uint32
if daclDefaulted {
        _p1 = 1
}
r1, _, e1 := syscall.Syscall6(procSetSecurityDescriptorDacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(_p0), uintptr(unsafe.Pointer(dacl)), uintptr(_p1), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setSecurityDescriptorGroup(sd *SECURITY_DESCRIPTOR, group *SID, groupDefaulted bool) (err error) {</p>

<pre>var _p0 uint32
if groupDefaulted {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procSetSecurityDescriptorGroup.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(group)), uintptr(_p0))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setSecurityDescriptorOwner(sd *SECURITY_DESCRIPTOR, owner *SID, ownerDefaulted bool) (err error) {</p>

<pre>var _p0 uint32
if ownerDefaulted {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procSetSecurityDescriptorOwner.Addr(), 3, uintptr(unsafe.Pointer(sd)), uintptr(unsafe.Pointer(owner)), uintptr(_p0))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setSecurityDescriptorRMControl(sd *SECURITY_DESCRIPTOR, rmControl *uint8) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procSetSecurityDescriptorRMControl</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">2</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">sd</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">rmControl</span>)), <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func setSecurityDescriptorSacl(sd *SECURITY_DESCRIPTOR, saclPresent bool, sacl *ACL, saclDefaulted bool) (err error) {</p>

<pre>var _p0 uint32
if saclPresent {
        _p0 = 1
}
var _p1 uint32
if saclDefaulted {
        _p1 = 1
}
r1, _, e1 := syscall.Syscall6(procSetSecurityDescriptorSacl.Addr(), 4, uintptr(unsafe.Pointer(sd)), uintptr(_p0), uintptr(unsafe.Pointer(sacl)), uintptr(_p1), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetSecurityInfo(handle Handle, objectType SE_OBJECT_TYPE, securityInformation SECURITY_INFORMATION, owner *SID, group *SID, dacl *ACL, sacl *ACL) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall9(procSetSecurityInfo.Addr(), 7, uintptr(handle), uintptr(objectType), uintptr(securityInformation), uintptr(unsafe.Pointer(owner)), uintptr(unsafe.Pointer(group)), uintptr(unsafe.Pointer(dacl)), uintptr(unsafe.Pointer(sacl)), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func SetServiceStatus(service Handle, serviceStatus *SERVICE_STATUS) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetServiceStatus.Addr(), 2, uintptr(service), uintptr(unsafe.Pointer(serviceStatus)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetThreadToken(thread *Handle, token Token) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetThreadToken.Addr(), 2, uintptr(unsafe.Pointer(thread)), uintptr(token), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetTokenInformation(token Token, infoClass uint32, info *byte, infoLen uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetTokenInformation.Addr(), 4, uintptr(token), uintptr(infoClass), uintptr(unsafe.Pointer(info)), uintptr(infoLen), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func StartServiceCtrlDispatcher(serviceTable *SERVICE_TABLE_ENTRY) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procStartServiceCtrlDispatcherW.Addr(), 1, uintptr(unsafe.Pointer(serviceTable)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func StartService(service Handle, numArgs uint32, argVectors **uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procStartServiceW.Addr(), 3, uintptr(service), uintptr(numArgs), uintptr(unsafe.Pointer(argVectors)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertAddCertificateContextToStore(store Handle, certContext *CertContext, addDisposition uint32, storeContext **CertContext) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procCertAddCertificateContextToStore.Addr(), 4, uintptr(store), uintptr(unsafe.Pointer(certContext)), uintptr(addDisposition), uintptr(unsafe.Pointer(storeContext)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertCloseStore(store Handle, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCertCloseStore.Addr(), 2, uintptr(store), uintptr(flags), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertCreateCertificateContext(certEncodingType uint32, certEncoded *byte, encodedLen uint32) (context *CertContext, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procCertCreateCertificateContext.Addr(), 3, uintptr(certEncodingType), uintptr(unsafe.Pointer(certEncoded)), uintptr(encodedLen))
context = (*CertContext)(unsafe.Pointer(r0))
if context == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertDeleteCertificateFromStore(certContext *CertContext) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCertDeleteCertificateFromStore.Addr(), 1, uintptr(unsafe.Pointer(certContext)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertDuplicateCertificateContext(certContext *CertContext) (dupContext *CertContext) {</p>

<pre>r0, _, _ := syscall.Syscall(procCertDuplicateCertificateContext.Addr(), 1, uintptr(unsafe.Pointer(certContext)), 0, 0)
dupContext = (*CertContext)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func CertEnumCertificatesInStore(store Handle, prevContext *CertContext) (context *CertContext, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procCertEnumCertificatesInStore.Addr(), 2, uintptr(store), uintptr(unsafe.Pointer(prevContext)), 0)
context = (*CertContext)(unsafe.Pointer(r0))
if context == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertFindCertificateInStore(store Handle, certEncodingType uint32, findFlags uint32, findType uint32, findPara unsafe.Pointer, prevCertContext *CertContext) (cert *CertContext, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCertFindCertificateInStore.Addr(), 6, uintptr(store), uintptr(certEncodingType), uintptr(findFlags), uintptr(findType), uintptr(findPara), uintptr(unsafe.Pointer(prevCertContext)))
cert = (*CertContext)(unsafe.Pointer(r0))
if cert == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertFindChainInStore(store Handle, certEncodingType uint32, findFlags uint32, findType uint32, findPara unsafe.Pointer, prevChainContext *CertChainContext) (certchain *CertChainContext, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCertFindChainInStore.Addr(), 6, uintptr(store), uintptr(certEncodingType), uintptr(findFlags), uintptr(findType), uintptr(findPara), uintptr(unsafe.Pointer(prevChainContext)))
certchain = (*CertChainContext)(unsafe.Pointer(r0))
if certchain == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertFindExtension(objId *byte, countExtensions uint32, extensions *CertExtension) (ret *CertExtension) {</p>

<pre>r0, _, _ := syscall.Syscall(procCertFindExtension.Addr(), 3, uintptr(unsafe.Pointer(objId)), uintptr(countExtensions), uintptr(unsafe.Pointer(extensions)))
ret = (*CertExtension)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func CertFreeCertificateChain(ctx *CertChainContext) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procCertFreeCertificateChain</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">ctx</span>)), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func CertFreeCertificateContext(ctx *CertContext) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCertFreeCertificateContext.Addr(), 1, uintptr(unsafe.Pointer(ctx)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertGetCertificateChain(engine Handle, leaf *CertContext, time *Filetime, additionalStore Handle, para *CertChainPara, flags uint32, reserved uintptr, chainCtx **CertChainContext) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procCertGetCertificateChain.Addr(), 8, uintptr(engine), uintptr(unsafe.Pointer(leaf)), uintptr(unsafe.Pointer(time)), uintptr(additionalStore), uintptr(unsafe.Pointer(para)), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(chainCtx)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertGetNameString(certContext *CertContext, nameType uint32, flags uint32, typePara unsafe.Pointer, name *uint16, size uint32) (chars uint32) {</p>

<pre>r0, _, _ := syscall.Syscall6(procCertGetNameStringW.Addr(), 6, uintptr(unsafe.Pointer(certContext)), uintptr(nameType), uintptr(flags), uintptr(typePara), uintptr(unsafe.Pointer(name)), uintptr(size))
chars = uint32(r0)
return</pre>

<p>}</p>

<p>func CertOpenStore(storeProvider uintptr, msgAndCertEncodingType uint32, cryptProv uintptr, flags uint32, para uintptr) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCertOpenStore.Addr(), 5, uintptr(storeProvider), uintptr(msgAndCertEncodingType), uintptr(cryptProv), uintptr(flags), uintptr(para), 0)
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertOpenSystemStore(hprov Handle, name *uint16) (store Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procCertOpenSystemStoreW.Addr(), 2, uintptr(hprov), uintptr(unsafe.Pointer(name)), 0)
store = Handle(r0)
if store == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CertVerifyCertificateChainPolicy(policyOID uintptr, chain *CertChainContext, para *CertChainPolicyPara, status *CertChainPolicyStatus) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procCertVerifyCertificateChainPolicy.Addr(), 4, uintptr(policyOID), uintptr(unsafe.Pointer(chain)), uintptr(unsafe.Pointer(para)), uintptr(unsafe.Pointer(status)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptAcquireCertificatePrivateKey(cert *CertContext, flags uint32, parameters unsafe.Pointer, cryptProvOrNCryptKey *Handle, keySpec *uint32, callerFreeProvOrNCryptKey *bool) (err error) {</p>

<pre>var _p0 uint32
if *callerFreeProvOrNCryptKey {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall6(procCryptAcquireCertificatePrivateKey.Addr(), 6, uintptr(unsafe.Pointer(cert)), uintptr(flags), uintptr(parameters), uintptr(unsafe.Pointer(cryptProvOrNCryptKey)), uintptr(unsafe.Pointer(keySpec)), uintptr(unsafe.Pointer(&amp;_p0)))
*callerFreeProvOrNCryptKey = _p0 != 0
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptDecodeObject(encodingType uint32, structType *byte, encodedBytes *byte, lenEncodedBytes uint32, flags uint32, decoded unsafe.Pointer, decodedLen *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procCryptDecodeObject.Addr(), 7, uintptr(encodingType), uintptr(unsafe.Pointer(structType)), uintptr(unsafe.Pointer(encodedBytes)), uintptr(lenEncodedBytes), uintptr(flags), uintptr(decoded), uintptr(unsafe.Pointer(decodedLen)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptProtectData(dataIn *DataBlob, name *uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procCryptProtectData.Addr(), 7, uintptr(unsafe.Pointer(dataIn)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(optionalEntropy)), uintptr(reserved), uintptr(unsafe.Pointer(promptStruct)), uintptr(flags), uintptr(unsafe.Pointer(dataOut)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptQueryObject(objectType uint32, object unsafe.Pointer, expectedContentTypeFlags uint32, expectedFormatTypeFlags uint32, flags uint32, msgAndCertEncodingType *uint32, contentType *uint32, formatType *uint32, certStore *Handle, msg *Handle, context *unsafe.Pointer) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall12(procCryptQueryObject.Addr(), 11, uintptr(objectType), uintptr(object), uintptr(expectedContentTypeFlags), uintptr(expectedFormatTypeFlags), uintptr(flags), uintptr(unsafe.Pointer(msgAndCertEncodingType)), uintptr(unsafe.Pointer(contentType)), uintptr(unsafe.Pointer(formatType)), uintptr(unsafe.Pointer(certStore)), uintptr(unsafe.Pointer(msg)), uintptr(unsafe.Pointer(context)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CryptUnprotectData(dataIn *DataBlob, name **uint16, optionalEntropy *DataBlob, reserved uintptr, promptStruct *CryptProtectPromptStruct, flags uint32, dataOut *DataBlob) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procCryptUnprotectData.Addr(), 7, uintptr(unsafe.Pointer(dataIn)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(optionalEntropy)), uintptr(reserved), uintptr(unsafe.Pointer(promptStruct)), uintptr(flags), uintptr(unsafe.Pointer(dataOut)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func PFXImportCertStore(pfx *CryptDataBlob, password *uint16, flags uint32) (store Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procPFXImportCertStore.Addr(), 3, uintptr(unsafe.Pointer(pfx)), uintptr(unsafe.Pointer(password)), uintptr(flags))
store = Handle(r0)
if store == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DnsNameCompare(name1 *uint16, name2 *uint16) (same bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procDnsNameCompare_W.Addr(), 2, uintptr(unsafe.Pointer(name1)), uintptr(unsafe.Pointer(name2)), 0)
same = r0 != 0
return</pre>

<p>}</p>

<p>func DnsQuery(name string, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) {</p>

<pre>var _p0 *uint16
_p0, status = syscall.UTF16PtrFromString(name)
if status != nil {
        return
}
return _DnsQuery(_p0, qtype, options, extra, qrs, pr)</pre>

<p>}</p>

<p>func _DnsQuery(name *uint16, qtype uint16, options uint32, extra *byte, qrs **DNSRecord, pr *byte) (status error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procDnsQuery_W.Addr(), 6, uintptr(unsafe.Pointer(name)), uintptr(qtype), uintptr(options), uintptr(unsafe.Pointer(extra)), uintptr(unsafe.Pointer(qrs)), uintptr(unsafe.Pointer(pr)))
if r0 != 0 {
        status = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func DnsRecordListFree(rl *DNSRecord, freetype uint32) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procDnsRecordListFree</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">2</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">rl</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">freetype</span>), <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func DwmGetWindowAttribute(hwnd HWND, attribute uint32, value unsafe.Pointer, size uint32) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procDwmGetWindowAttribute.Addr(), 4, uintptr(hwnd), uintptr(attribute), uintptr(value), uintptr(size), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func DwmSetWindowAttribute(hwnd HWND, attribute uint32, value unsafe.Pointer, size uint32) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procDwmSetWindowAttribute.Addr(), 4, uintptr(hwnd), uintptr(attribute), uintptr(value), uintptr(size), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func GetAdaptersAddresses(family uint32, flags uint32, reserved uintptr, adapterAddresses *IpAdapterAddresses, sizePointer *uint32) (errcode error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procGetAdaptersAddresses.Addr(), 5, uintptr(family), uintptr(flags), uintptr(reserved), uintptr(unsafe.Pointer(adapterAddresses)), uintptr(unsafe.Pointer(sizePointer)), 0)
if r0 != 0 {
        errcode = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func GetAdaptersInfo(ai *IpAdapterInfo, ol *uint32) (errcode error) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetAdaptersInfo.Addr(), 2, uintptr(unsafe.Pointer(ai)), uintptr(unsafe.Pointer(ol)), 0)
if r0 != 0 {
        errcode = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func getBestInterfaceEx(sockaddr unsafe.Pointer, pdwBestIfIndex *uint32) (errcode error) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetBestInterfaceEx.Addr(), 2, uintptr(sockaddr), uintptr(unsafe.Pointer(pdwBestIfIndex)), 0)
if r0 != 0 {
        errcode = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func GetIfEntry(pIfRow *MibIfRow) (errcode error) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetIfEntry.Addr(), 1, uintptr(unsafe.Pointer(pIfRow)), 0, 0)
if r0 != 0 {
        errcode = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func AssignProcessToJobObject(job Handle, process Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procAssignProcessToJobObject.Addr(), 2, uintptr(job), uintptr(process), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CancelIo(s Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCancelIo.Addr(), 1, uintptr(s), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CancelIoEx(s Handle, o *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCancelIoEx.Addr(), 2, uintptr(s), uintptr(unsafe.Pointer(o)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CloseHandle(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCloseHandle.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ConnectNamedPipe(pipe Handle, overlapped *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procConnectNamedPipe.Addr(), 2, uintptr(pipe), uintptr(unsafe.Pointer(overlapped)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateDirectory(path *uint16, sa *SecurityAttributes) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCreateDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(sa)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateEventEx(eventAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCreateEventExW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(desiredAccess), 0, 0)
handle = Handle(r0)
if handle == 0 || e1 == ERROR_ALREADY_EXISTS {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateEvent(eventAttrs *SecurityAttributes, manualReset uint32, initialState uint32, name *uint16) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCreateEventW.Addr(), 4, uintptr(unsafe.Pointer(eventAttrs)), uintptr(manualReset), uintptr(initialState), uintptr(unsafe.Pointer(name)), 0, 0)
handle = Handle(r0)
if handle == 0 || e1 == ERROR_ALREADY_EXISTS {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateFileMapping(fhandle Handle, sa *SecurityAttributes, prot uint32, maxSizeHigh uint32, maxSizeLow uint32, name *uint16) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCreateFileMappingW.Addr(), 6, uintptr(fhandle), uintptr(unsafe.Pointer(sa)), uintptr(prot), uintptr(maxSizeHigh), uintptr(maxSizeLow), uintptr(unsafe.Pointer(name)))
handle = Handle(r0)
if handle == 0 || e1 == ERROR_ALREADY_EXISTS {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateFile(name *uint16, access uint32, mode uint32, sa *SecurityAttributes, createmode uint32, attrs uint32, templatefile Handle) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall9(procCreateFileW.Addr(), 7, uintptr(unsafe.Pointer(name)), uintptr(access), uintptr(mode), uintptr(unsafe.Pointer(sa)), uintptr(createmode), uintptr(attrs), uintptr(templatefile), 0, 0)
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateHardLink(filename *uint16, existingfilename *uint16, reserved uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCreateHardLinkW.Addr(), 3, uintptr(unsafe.Pointer(filename)), uintptr(unsafe.Pointer(existingfilename)), uintptr(reserved))
if r1&amp;0xff == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateIoCompletionPort(filehandle Handle, cphandle Handle, key uintptr, threadcnt uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCreateIoCompletionPort.Addr(), 4, uintptr(filehandle), uintptr(cphandle), uintptr(key), uintptr(threadcnt), 0, 0)
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateJobObject(jobAttr *SecurityAttributes, name *uint16) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procCreateJobObjectW.Addr(), 2, uintptr(unsafe.Pointer(jobAttr)), uintptr(unsafe.Pointer(name)), 0)
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateMutexEx(mutexAttrs *SecurityAttributes, name *uint16, flags uint32, desiredAccess uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procCreateMutexExW.Addr(), 4, uintptr(unsafe.Pointer(mutexAttrs)), uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(desiredAccess), 0, 0)
handle = Handle(r0)
if handle == 0 || e1 == ERROR_ALREADY_EXISTS {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateMutex(mutexAttrs *SecurityAttributes, initialOwner bool, name *uint16) (handle Handle, err error) {</p>

<pre>var _p0 uint32
if initialOwner {
        _p0 = 1
}
r0, _, e1 := syscall.Syscall(procCreateMutexW.Addr(), 3, uintptr(unsafe.Pointer(mutexAttrs)), uintptr(_p0), uintptr(unsafe.Pointer(name)))
handle = Handle(r0)
if handle == 0 || e1 == ERROR_ALREADY_EXISTS {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateNamedPipe(name *uint16, flags uint32, pipeMode uint32, maxInstances uint32, outSize uint32, inSize uint32, defaultTimeout uint32, sa *SecurityAttributes) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall9(procCreateNamedPipeW.Addr(), 8, uintptr(unsafe.Pointer(name)), uintptr(flags), uintptr(pipeMode), uintptr(maxInstances), uintptr(outSize), uintptr(inSize), uintptr(defaultTimeout), uintptr(unsafe.Pointer(sa)), 0)
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreatePipe(readhandle *Handle, writehandle *Handle, sa *SecurityAttributes, size uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procCreatePipe.Addr(), 4, uintptr(unsafe.Pointer(readhandle)), uintptr(unsafe.Pointer(writehandle)), uintptr(unsafe.Pointer(sa)), uintptr(size), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateProcess(appName *uint16, commandLine *uint16, procSecurity *SecurityAttributes, threadSecurity *SecurityAttributes, inheritHandles bool, creationFlags uint32, env *uint16, currentDir *uint16, startupInfo *StartupInfo, outProcInfo *ProcessInformation) (err error) {</p>

<pre>var _p0 uint32
if inheritHandles {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall12(procCreateProcessW.Addr(), 10, uintptr(unsafe.Pointer(appName)), uintptr(unsafe.Pointer(commandLine)), uintptr(unsafe.Pointer(procSecurity)), uintptr(unsafe.Pointer(threadSecurity)), uintptr(_p0), uintptr(creationFlags), uintptr(unsafe.Pointer(env)), uintptr(unsafe.Pointer(currentDir)), uintptr(unsafe.Pointer(startupInfo)), uintptr(unsafe.Pointer(outProcInfo)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateSymbolicLink(symlinkfilename *uint16, targetfilename *uint16, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procCreateSymbolicLinkW.Addr(), 3, uintptr(unsafe.Pointer(symlinkfilename)), uintptr(unsafe.Pointer(targetfilename)), uintptr(flags))
if r1&amp;0xff == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateToolhelp32Snapshot(flags uint32, processId uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procCreateToolhelp32Snapshot.Addr(), 2, uintptr(flags), uintptr(processId), 0)
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DefineDosDevice(flags uint32, deviceName *uint16, targetPath *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procDefineDosDeviceW.Addr(), 3, uintptr(flags), uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DeleteFile(path *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procDeleteFileW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func deleteProcThreadAttributeList(attrlist *ProcThreadAttributeList) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procDeleteProcThreadAttributeList</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">attrlist</span>)), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func DeleteVolumeMountPoint(volumeMountPoint *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procDeleteVolumeMountPointW.Addr(), 1, uintptr(unsafe.Pointer(volumeMountPoint)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DeviceIoControl(handle Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procDeviceIoControl.Addr(), 8, uintptr(handle), uintptr(ioControlCode), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferSize), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferSize), uintptr(unsafe.Pointer(bytesReturned)), uintptr(unsafe.Pointer(overlapped)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DuplicateHandle(hSourceProcessHandle Handle, hSourceHandle Handle, hTargetProcessHandle Handle, lpTargetHandle *Handle, dwDesiredAccess uint32, bInheritHandle bool, dwOptions uint32) (err error) {</p>

<pre>var _p0 uint32
if bInheritHandle {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall9(procDuplicateHandle.Addr(), 7, uintptr(hSourceProcessHandle), uintptr(hSourceHandle), uintptr(hTargetProcessHandle), uintptr(unsafe.Pointer(lpTargetHandle)), uintptr(dwDesiredAccess), uintptr(_p0), uintptr(dwOptions), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ExitProcess(exitcode uint32) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procExitProcess</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">exitcode</span>), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func ExpandEnvironmentStrings(src *uint16, dst *uint16, size uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procExpandEnvironmentStringsW.Addr(), 3, uintptr(unsafe.Pointer(src)), uintptr(unsafe.Pointer(dst)), uintptr(size))
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindClose(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindClose.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindCloseChangeNotification(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindCloseChangeNotification.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindFirstChangeNotification(path string, watchSubtree bool, notifyFilter uint32) (handle Handle, err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(path)
if err != nil {
        return
}
return _FindFirstChangeNotification(_p0, watchSubtree, notifyFilter)</pre>

<p>}</p>

<p>func _FindFirstChangeNotification(path *uint16, watchSubtree bool, notifyFilter uint32) (handle Handle, err error) {</p>

<pre>var _p1 uint32
if watchSubtree {
        _p1 = 1
}
r0, _, e1 := syscall.Syscall(procFindFirstChangeNotificationW.Addr(), 3, uintptr(unsafe.Pointer(path)), uintptr(_p1), uintptr(notifyFilter))
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func findFirstFile1(name *uint16, data *win32finddata1) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procFindFirstFileW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(data)), 0)
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindFirstVolumeMountPoint(rootPathName *uint16, volumeMountPoint *uint16, bufferLength uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procFindFirstVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindFirstVolume(volumeName *uint16, bufferLength uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procFindFirstVolumeW.Addr(), 2, uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength), 0)
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindNextChangeNotification(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindNextChangeNotification.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func findNextFile1(handle Handle, data *win32finddata1) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindNextFileW.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindNextVolumeMountPoint(findVolumeMountPoint Handle, volumeMountPoint *uint16, bufferLength uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindNextVolumeMountPointW.Addr(), 3, uintptr(findVolumeMountPoint), uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(bufferLength))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindNextVolume(findVolume Handle, volumeName *uint16, bufferLength uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindNextVolumeW.Addr(), 3, uintptr(findVolume), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferLength))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func findResource(module Handle, name uintptr, resType uintptr) (resInfo Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procFindResourceW.Addr(), 3, uintptr(module), uintptr(name), uintptr(resType))
resInfo = Handle(r0)
if resInfo == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindVolumeClose(findVolume Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindVolumeClose.Addr(), 1, uintptr(findVolume), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FindVolumeMountPointClose(findVolumeMountPoint Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFindVolumeMountPointClose.Addr(), 1, uintptr(findVolumeMountPoint), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FlushFileBuffers(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFlushFileBuffers.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FlushViewOfFile(addr uintptr, length uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFlushViewOfFile.Addr(), 2, uintptr(addr), uintptr(length), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FormatMessage(flags uint32, msgsrc uintptr, msgid uint32, langid uint32, buf []uint16, args *byte) (n uint32, err error) {</p>

<pre>var _p0 *uint16
if len(buf) &gt; 0 {
        _p0 = &amp;buf[0]
}
r0, _, e1 := syscall.Syscall9(procFormatMessageW.Addr(), 7, uintptr(flags), uintptr(msgsrc), uintptr(msgid), uintptr(langid), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(args)), 0, 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FreeEnvironmentStrings(envs *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFreeEnvironmentStringsW.Addr(), 1, uintptr(unsafe.Pointer(envs)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func FreeLibrary(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procFreeLibrary.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GenerateConsoleCtrlEvent(ctrlEvent uint32, processGroupID uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGenerateConsoleCtrlEvent.Addr(), 2, uintptr(ctrlEvent), uintptr(processGroupID), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetACP() (acp uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetACP.Addr(), 0, 0, 0, 0)
acp = uint32(r0)
return</pre>

<p>}</p>

<p>func GetActiveProcessorCount(groupNumber uint16) (ret uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetActiveProcessorCount.Addr(), 1, uintptr(groupNumber), 0, 0)
ret = uint32(r0)
return</pre>

<p>}</p>

<p>func GetCommTimeouts(handle Handle, timeouts *CommTimeouts) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetCommTimeouts.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(timeouts)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetCommandLine() (cmd *uint16) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetCommandLineW.Addr(), 0, 0, 0, 0)
cmd = (*uint16)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func GetComputerNameEx(nametype uint32, buf *uint16, n *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetComputerNameExW.Addr(), 3, uintptr(nametype), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetComputerName(buf *uint16, n *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetComputerNameW.Addr(), 2, uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(n)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetConsoleMode(console Handle, mode *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetConsoleMode.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(mode)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetConsoleScreenBufferInfo(console Handle, info *ConsoleScreenBufferInfo) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetConsoleScreenBufferInfo.Addr(), 2, uintptr(console), uintptr(unsafe.Pointer(info)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetCurrentDirectory(buflen uint32, buf *uint16) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetCurrentDirectoryW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetCurrentProcessId() (pid uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetCurrentProcessId.Addr(), 0, 0, 0, 0)
pid = uint32(r0)
return</pre>

<p>}</p>

<p>func GetCurrentThreadId() (id uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetCurrentThreadId.Addr(), 0, 0, 0, 0)
id = uint32(r0)
return</pre>

<p>}</p>

<p>func GetDiskFreeSpaceEx(directoryName *uint16, freeBytesAvailableToCaller *uint64, totalNumberOfBytes *uint64, totalNumberOfFreeBytes *uint64) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetDiskFreeSpaceExW.Addr(), 4, uintptr(unsafe.Pointer(directoryName)), uintptr(unsafe.Pointer(freeBytesAvailableToCaller)), uintptr(unsafe.Pointer(totalNumberOfBytes)), uintptr(unsafe.Pointer(totalNumberOfFreeBytes)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetDriveType(rootPathName *uint16) (driveType uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetDriveTypeW.Addr(), 1, uintptr(unsafe.Pointer(rootPathName)), 0, 0)
driveType = uint32(r0)
return</pre>

<p>}</p>

<p>func GetEnvironmentStrings() (envs *uint16, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetEnvironmentStringsW.Addr(), 0, 0, 0, 0)
envs = (*uint16)(unsafe.Pointer(r0))
if envs == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetEnvironmentVariable(name *uint16, buffer *uint16, size uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetEnvironmentVariableW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(buffer)), uintptr(size))
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetExitCodeProcess(handle Handle, exitcode *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetExitCodeProcess.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(exitcode)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileAttributesEx(name *uint16, level uint32, info *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetFileAttributesExW.Addr(), 3, uintptr(unsafe.Pointer(name)), uintptr(level), uintptr(unsafe.Pointer(info)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileAttributes(name *uint16) (attrs uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetFileAttributesW.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
attrs = uint32(r0)
if attrs == INVALID_FILE_ATTRIBUTES {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileInformationByHandle(handle Handle, data *ByHandleFileInformation) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetFileInformationByHandle.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(data)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileInformationByHandleEx(handle Handle, class uint32, outBuffer *byte, outBufferLen uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetFileInformationByHandleEx.Addr(), 4, uintptr(handle), uintptr(class), uintptr(unsafe.Pointer(outBuffer)), uintptr(outBufferLen), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileType(filehandle Handle) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetFileType.Addr(), 1, uintptr(filehandle), 0, 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFinalPathNameByHandle(file Handle, filePath *uint16, filePathSize uint32, flags uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procGetFinalPathNameByHandleW.Addr(), 4, uintptr(file), uintptr(unsafe.Pointer(filePath)), uintptr(filePathSize), uintptr(flags), 0, 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFullPathName(path *uint16, buflen uint32, buf *uint16, fname **uint16) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procGetFullPathNameW.Addr(), 4, uintptr(unsafe.Pointer(path)), uintptr(buflen), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(fname)), 0, 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetLargePageMinimum() (size uintptr) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetLargePageMinimum.Addr(), 0, 0, 0, 0)
size = uintptr(r0)
return</pre>

<p>}</p>

<p>func GetLastError() (lasterr error) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetLastError.Addr(), 0, 0, 0, 0)
if r0 != 0 {
        lasterr = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func GetLogicalDriveStrings(bufferLength uint32, buffer *uint16) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetLogicalDriveStringsW.Addr(), 2, uintptr(bufferLength), uintptr(unsafe.Pointer(buffer)), 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetLogicalDrives() (drivesBitMask uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetLogicalDrives.Addr(), 0, 0, 0, 0)
drivesBitMask = uint32(r0)
if drivesBitMask == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetLongPathName(path *uint16, buf *uint16, buflen uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetLongPathNameW.Addr(), 3, uintptr(unsafe.Pointer(path)), uintptr(unsafe.Pointer(buf)), uintptr(buflen))
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetMaximumProcessorCount(groupNumber uint16) (ret uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetMaximumProcessorCount.Addr(), 1, uintptr(groupNumber), 0, 0)
ret = uint32(r0)
return</pre>

<p>}</p>

<p>func GetModuleFileName(module Handle, filename *uint16, size uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetModuleFileNameW.Addr(), 3, uintptr(module), uintptr(unsafe.Pointer(filename)), uintptr(size))
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetModuleHandleEx(flags uint32, moduleName *uint16, module *Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetModuleHandleExW.Addr(), 3, uintptr(flags), uintptr(unsafe.Pointer(moduleName)), uintptr(unsafe.Pointer(module)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetNamedPipeHandleState(pipe Handle, state *uint32, curInstances *uint32, maxCollectionCount *uint32, collectDataTimeout *uint32, userName *uint16, maxUserNameSize uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procGetNamedPipeHandleStateW.Addr(), 7, uintptr(pipe), uintptr(unsafe.Pointer(state)), uintptr(unsafe.Pointer(curInstances)), uintptr(unsafe.Pointer(maxCollectionCount)), uintptr(unsafe.Pointer(collectDataTimeout)), uintptr(unsafe.Pointer(userName)), uintptr(maxUserNameSize), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetNamedPipeInfo(pipe Handle, flags *uint32, outSize *uint32, inSize *uint32, maxInstances *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetNamedPipeInfo.Addr(), 5, uintptr(pipe), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(outSize)), uintptr(unsafe.Pointer(inSize)), uintptr(unsafe.Pointer(maxInstances)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetOverlappedResult(handle Handle, overlapped *Overlapped, done *uint32, wait bool) (err error) {</p>

<pre>var _p0 uint32
if wait {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall6(procGetOverlappedResult.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(done)), uintptr(_p0), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetPriorityClass(process Handle) (ret uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetPriorityClass.Addr(), 1, uintptr(process), 0, 0)
ret = uint32(r0)
if ret == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetProcAddress(module Handle, procname string) (proc uintptr, err error) {</p>

<pre>var _p0 *byte
_p0, err = syscall.BytePtrFromString(procname)
if err != nil {
        return
}
return _GetProcAddress(module, _p0)</pre>

<p>}</p>

<p>func _GetProcAddress(module Handle, procname *byte) (proc uintptr, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetProcAddress.Addr(), 2, uintptr(module), uintptr(unsafe.Pointer(procname)), 0)
proc = uintptr(r0)
if proc == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetProcessId(process Handle) (id uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetProcessId.Addr(), 1, uintptr(process), 0, 0)
id = uint32(r0)
if id == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getProcessPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetProcessPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetProcessShutdownParameters(level *uint32, flags *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetProcessShutdownParameters.Addr(), 2, uintptr(unsafe.Pointer(level)), uintptr(unsafe.Pointer(flags)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetProcessTimes(handle Handle, creationTime *Filetime, exitTime *Filetime, kernelTime *Filetime, userTime *Filetime) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetProcessTimes.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(creationTime)), uintptr(unsafe.Pointer(exitTime)), uintptr(unsafe.Pointer(kernelTime)), uintptr(unsafe.Pointer(userTime)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetProcessWorkingSetSizeEx(hProcess Handle, lpMinimumWorkingSetSize *uintptr, lpMaximumWorkingSetSize *uintptr, flags *uint32) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall6</span>(<span class="ruby-identifier">procGetProcessWorkingSetSizeEx</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">4</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">hProcess</span>), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">lpMinimumWorkingSetSize</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">lpMaximumWorkingSetSize</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">flags</span>)), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func GetQueuedCompletionStatus(cphandle Handle, qty *uint32, key *uintptr, overlapped **Overlapped, timeout uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetQueuedCompletionStatus.Addr(), 5, uintptr(cphandle), uintptr(unsafe.Pointer(qty)), uintptr(unsafe.Pointer(key)), uintptr(unsafe.Pointer(overlapped)), uintptr(timeout), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetShortPathName(longpath *uint16, shortpath *uint16, buflen uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetShortPathNameW.Addr(), 3, uintptr(unsafe.Pointer(longpath)), uintptr(unsafe.Pointer(shortpath)), uintptr(buflen))
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetStartupInfo(startupInfo *StartupInfo) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetStartupInfoW.Addr(), 1, uintptr(unsafe.Pointer(startupInfo)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetStdHandle(stdhandle uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetStdHandle.Addr(), 1, uintptr(stdhandle), 0, 0)
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSystemDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetSystemDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
len = uint32(r0)
if len == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getSystemPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetSystemPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetSystemTimeAsFileTime(time *Filetime) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procGetSystemTimeAsFileTime</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">time</span>)), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func GetSystemTimePreciseAsFileTime(time *Filetime) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procGetSystemTimePreciseAsFileTime</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">time</span>)), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func getSystemWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetSystemWindowsDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
len = uint32(r0)
if len == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetTempPath(buflen uint32, buf *uint16) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetTempPathW.Addr(), 2, uintptr(buflen), uintptr(unsafe.Pointer(buf)), 0)
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getThreadPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetThreadPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getTickCount64() (ms uint64) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetTickCount64.Addr(), 0, 0, 0, 0)
ms = uint64(r0)
return</pre>

<p>}</p>

<p>func GetTimeZoneInformation(tzi *Timezoneinformation) (rc uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetTimeZoneInformation.Addr(), 1, uintptr(unsafe.Pointer(tzi)), 0, 0)
rc = uint32(r0)
if rc == 0xffffffff {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getUserPreferredUILanguages(flags uint32, numLanguages *uint32, buf *uint16, bufSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetUserPreferredUILanguages.Addr(), 4, uintptr(flags), uintptr(unsafe.Pointer(numLanguages)), uintptr(unsafe.Pointer(buf)), uintptr(unsafe.Pointer(bufSize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetVersion() (ver uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetVersion.Addr(), 0, 0, 0, 0)
ver = uint32(r0)
if ver == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetVolumeInformationByHandle(file Handle, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procGetVolumeInformationByHandleW.Addr(), 8, uintptr(file), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetVolumeInformation(rootPathName *uint16, volumeNameBuffer *uint16, volumeNameSize uint32, volumeNameSerialNumber *uint32, maximumComponentLength *uint32, fileSystemFlags *uint32, fileSystemNameBuffer *uint16, fileSystemNameSize uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procGetVolumeInformationW.Addr(), 8, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeNameBuffer)), uintptr(volumeNameSize), uintptr(unsafe.Pointer(volumeNameSerialNumber)), uintptr(unsafe.Pointer(maximumComponentLength)), uintptr(unsafe.Pointer(fileSystemFlags)), uintptr(unsafe.Pointer(fileSystemNameBuffer)), uintptr(fileSystemNameSize), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetVolumeNameForVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16, bufferlength uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetVolumeNameForVolumeMountPointW.Addr(), 3, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), uintptr(bufferlength))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetVolumePathName(fileName *uint16, volumePathName *uint16, bufferLength uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetVolumePathNameW.Addr(), 3, uintptr(unsafe.Pointer(fileName)), uintptr(unsafe.Pointer(volumePathName)), uintptr(bufferLength))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetVolumePathNamesForVolumeName(volumeName *uint16, volumePathNames *uint16, bufferLength uint32, returnLength *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetVolumePathNamesForVolumeNameW.Addr(), 4, uintptr(unsafe.Pointer(volumeName)), uintptr(unsafe.Pointer(volumePathNames)), uintptr(bufferLength), uintptr(unsafe.Pointer(returnLength)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getWindowsDirectory(dir *uint16, dirLen uint32) (len uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetWindowsDirectoryW.Addr(), 2, uintptr(unsafe.Pointer(dir)), uintptr(dirLen), 0)
len = uint32(r0)
if len == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func initializeProcThreadAttributeList(attrlist *ProcThreadAttributeList, attrcount uint32, flags uint32, size *uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procInitializeProcThreadAttributeList.Addr(), 4, uintptr(unsafe.Pointer(attrlist)), uintptr(attrcount), uintptr(flags), uintptr(unsafe.Pointer(size)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func IsWow64Process(handle Handle, isWow64 *bool) (err error) {</p>

<pre>var _p0 uint32
if *isWow64 {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procIsWow64Process.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(&amp;_p0)), 0)
*isWow64 = _p0 != 0
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func IsWow64Process2(handle Handle, processMachine *uint16, nativeMachine *uint16) (err error) {</p>

<pre>err = procIsWow64Process2.Find()
if err != nil {
        return
}
r1, _, e1 := syscall.Syscall(procIsWow64Process2.Addr(), 3, uintptr(handle), uintptr(unsafe.Pointer(processMachine)), uintptr(unsafe.Pointer(nativeMachine)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LoadLibraryEx(libname string, zero Handle, flags uintptr) (handle Handle, err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(libname)
if err != nil {
        return
}
return _LoadLibraryEx(_p0, zero, flags)</pre>

<p>}</p>

<p>func _LoadLibraryEx(libname *uint16, zero Handle, flags uintptr) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procLoadLibraryExW.Addr(), 3, uintptr(unsafe.Pointer(libname)), uintptr(zero), uintptr(flags))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LoadLibrary(libname string) (handle Handle, err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(libname)
if err != nil {
        return
}
return _LoadLibrary(_p0)</pre>

<p>}</p>

<p>func _LoadLibrary(libname *uint16) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procLoadLibraryW.Addr(), 1, uintptr(unsafe.Pointer(libname)), 0, 0)
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LoadResource(module Handle, resInfo Handle) (resData Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procLoadResource.Addr(), 2, uintptr(module), uintptr(resInfo), 0)
resData = Handle(r0)
if resData == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LocalAlloc(flags uint32, length uint32) (ptr uintptr, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procLocalAlloc.Addr(), 2, uintptr(flags), uintptr(length), 0)
ptr = uintptr(r0)
if ptr == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LocalFree(hmem Handle) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procLocalFree.Addr(), 1, uintptr(hmem), 0, 0)
handle = Handle(r0)
if handle != 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LockFileEx(file Handle, flags uint32, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procLockFileEx.Addr(), 6, uintptr(file), uintptr(flags), uintptr(reserved), uintptr(bytesLow), uintptr(bytesHigh), uintptr(unsafe.Pointer(overlapped)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func LockResource(resData Handle) (addr uintptr, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procLockResource.Addr(), 1, uintptr(resData), 0, 0)
addr = uintptr(r0)
if addr == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func MapViewOfFile(handle Handle, access uint32, offsetHigh uint32, offsetLow uint32, length uintptr) (addr uintptr, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procMapViewOfFile.Addr(), 5, uintptr(handle), uintptr(access), uintptr(offsetHigh), uintptr(offsetLow), uintptr(length), 0)
addr = uintptr(r0)
if addr == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Module32First(snapshot Handle, moduleEntry *ModuleEntry32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procModule32FirstW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(moduleEntry)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Module32Next(snapshot Handle, moduleEntry *ModuleEntry32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procModule32NextW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(moduleEntry)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func MoveFileEx(from *uint16, to *uint16, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procMoveFileExW.Addr(), 3, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), uintptr(flags))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func MoveFile(from *uint16, to *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procMoveFileW.Addr(), 2, uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(to)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func MultiByteToWideChar(codePage uint32, dwFlags uint32, str *byte, nstr int32, wchar *uint16, nwchar int32) (nwrite int32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procMultiByteToWideChar.Addr(), 6, uintptr(codePage), uintptr(dwFlags), uintptr(unsafe.Pointer(str)), uintptr(nstr), uintptr(unsafe.Pointer(wchar)), uintptr(nwchar))
nwrite = int32(r0)
if nwrite == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenEvent(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) {</p>

<pre>var _p0 uint32
if inheritHandle {
        _p0 = 1
}
r0, _, e1 := syscall.Syscall(procOpenEventW.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(unsafe.Pointer(name)))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenMutex(desiredAccess uint32, inheritHandle bool, name *uint16) (handle Handle, err error) {</p>

<pre>var _p0 uint32
if inheritHandle {
        _p0 = 1
}
r0, _, e1 := syscall.Syscall(procOpenMutexW.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(unsafe.Pointer(name)))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenProcess(desiredAccess uint32, inheritHandle bool, processId uint32) (handle Handle, err error) {</p>

<pre>var _p0 uint32
if inheritHandle {
        _p0 = 1
}
r0, _, e1 := syscall.Syscall(procOpenProcess.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(processId))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func OpenThread(desiredAccess uint32, inheritHandle bool, threadId uint32) (handle Handle, err error) {</p>

<pre>var _p0 uint32
if inheritHandle {
        _p0 = 1
}
r0, _, e1 := syscall.Syscall(procOpenThread.Addr(), 3, uintptr(desiredAccess), uintptr(_p0), uintptr(threadId))
handle = Handle(r0)
if handle == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func PostQueuedCompletionStatus(cphandle Handle, qty uint32, key uintptr, overlapped *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procPostQueuedCompletionStatus.Addr(), 4, uintptr(cphandle), uintptr(qty), uintptr(key), uintptr(unsafe.Pointer(overlapped)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Process32First(snapshot Handle, procEntry *ProcessEntry32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procProcess32FirstW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Process32Next(snapshot Handle, procEntry *ProcessEntry32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procProcess32NextW.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(procEntry)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ProcessIdToSessionId(pid uint32, sessionid *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procProcessIdToSessionId.Addr(), 2, uintptr(pid), uintptr(unsafe.Pointer(sessionid)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func PulseEvent(event Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procPulseEvent.Addr(), 1, uintptr(event), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryDosDevice(deviceName *uint16, targetPath *uint16, max uint32) (n uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procQueryDosDeviceW.Addr(), 3, uintptr(unsafe.Pointer(deviceName)), uintptr(unsafe.Pointer(targetPath)), uintptr(max))
n = uint32(r0)
if n == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryFullProcessImageName(proc Handle, flags uint32, exeName *uint16, size *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procQueryFullProcessImageNameW.Addr(), 4, uintptr(proc), uintptr(flags), uintptr(unsafe.Pointer(exeName)), uintptr(unsafe.Pointer(size)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryInformationJobObject(job Handle, JobObjectInformationClass int32, JobObjectInformation uintptr, JobObjectInformationLength uint32, retlen *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procQueryInformationJobObject.Addr(), 5, uintptr(job), uintptr(JobObjectInformationClass), uintptr(JobObjectInformation), uintptr(JobObjectInformationLength), uintptr(unsafe.Pointer(retlen)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ReadConsole(console Handle, buf *uint16, toread uint32, read *uint32, inputControl *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procReadConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(toread), uintptr(unsafe.Pointer(read)), uintptr(unsafe.Pointer(inputControl)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ReadDirectoryChanges(handle Handle, buf *byte, buflen uint32, watchSubTree bool, mask uint32, retlen *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) {</p>

<pre>var _p0 uint32
if watchSubTree {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall9(procReadDirectoryChangesW.Addr(), 8, uintptr(handle), uintptr(unsafe.Pointer(buf)), uintptr(buflen), uintptr(_p0), uintptr(mask), uintptr(unsafe.Pointer(retlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func readFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) {</p>

<pre>var _p0 *byte
if len(buf) &gt; 0 {
        _p0 = &amp;buf[0]
}
r1, _, e1 := syscall.Syscall6(procReadFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ReadProcessMemory(process Handle, baseAddress uintptr, buffer *byte, size uintptr, numberOfBytesRead *uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procReadProcessMemory.Addr(), 5, uintptr(process), uintptr(baseAddress), uintptr(unsafe.Pointer(buffer)), uintptr(size), uintptr(unsafe.Pointer(numberOfBytesRead)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ReleaseMutex(mutex Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procReleaseMutex.Addr(), 1, uintptr(mutex), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func RemoveDirectory(path *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procRemoveDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ResetEvent(event Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procResetEvent.Addr(), 1, uintptr(event), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ResumeThread(thread Handle) (ret uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procResumeThread.Addr(), 1, uintptr(thread), 0, 0)
ret = uint32(r0)
if ret == 0xffffffff {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetCommTimeouts(handle Handle, timeouts *CommTimeouts) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetCommTimeouts.Addr(), 2, uintptr(handle), uintptr(unsafe.Pointer(timeouts)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setConsoleCursorPosition(console Handle, position uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetConsoleCursorPosition.Addr(), 2, uintptr(console), uintptr(position), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetConsoleMode(console Handle, mode uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetConsoleMode.Addr(), 2, uintptr(console), uintptr(mode), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetCurrentDirectory(path *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetCurrentDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetDefaultDllDirectories(directoryFlags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetDefaultDllDirectories.Addr(), 1, uintptr(directoryFlags), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetDllDirectory(path string) (err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(path)
if err != nil {
        return
}
return _SetDllDirectory(_p0)</pre>

<p>}</p>

<p>func _SetDllDirectory(path *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetDllDirectoryW.Addr(), 1, uintptr(unsafe.Pointer(path)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetEndOfFile(handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetEndOfFile.Addr(), 1, uintptr(handle), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetEnvironmentVariable(name *uint16, value *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetEnvironmentVariableW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(value)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetErrorMode(mode uint32) (ret uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procSetErrorMode.Addr(), 1, uintptr(mode), 0, 0)
ret = uint32(r0)
return</pre>

<p>}</p>

<p>func SetEvent(event Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetEvent.Addr(), 1, uintptr(event), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetFileAttributes(name *uint16, attrs uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetFileAttributesW.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(attrs), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetFileCompletionNotificationModes(handle Handle, flags uint8) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetFileCompletionNotificationModes.Addr(), 2, uintptr(handle), uintptr(flags), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetFileInformationByHandle(handle Handle, class uint32, inBuffer *byte, inBufferLen uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetFileInformationByHandle.Addr(), 4, uintptr(handle), uintptr(class), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferLen), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetFilePointer(handle Handle, lowoffset int32, highoffsetptr *int32, whence uint32) (newlowoffset uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procSetFilePointer.Addr(), 4, uintptr(handle), uintptr(lowoffset), uintptr(unsafe.Pointer(highoffsetptr)), uintptr(whence), 0, 0)
newlowoffset = uint32(r0)
if newlowoffset == 0xffffffff {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetFileTime(handle Handle, ctime *Filetime, atime *Filetime, wtime *Filetime) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetFileTime.Addr(), 4, uintptr(handle), uintptr(unsafe.Pointer(ctime)), uintptr(unsafe.Pointer(atime)), uintptr(unsafe.Pointer(wtime)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetHandleInformation(handle Handle, mask uint32, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetHandleInformation.Addr(), 3, uintptr(handle), uintptr(mask), uintptr(flags))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetInformationJobObject(job Handle, JobObjectInformationClass uint32, JobObjectInformation uintptr, JobObjectInformationLength uint32) (ret int, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procSetInformationJobObject.Addr(), 4, uintptr(job), uintptr(JobObjectInformationClass), uintptr(JobObjectInformation), uintptr(JobObjectInformationLength), 0, 0)
ret = int(r0)
if ret == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetNamedPipeHandleState(pipe Handle, state *uint32, maxCollectionCount *uint32, collectDataTimeout *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetNamedPipeHandleState.Addr(), 4, uintptr(pipe), uintptr(unsafe.Pointer(state)), uintptr(unsafe.Pointer(maxCollectionCount)), uintptr(unsafe.Pointer(collectDataTimeout)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetPriorityClass(process Handle, priorityClass uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetPriorityClass.Addr(), 2, uintptr(process), uintptr(priorityClass), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetProcessPriorityBoost(process Handle, disable bool) (err error) {</p>

<pre>var _p0 uint32
if disable {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procSetProcessPriorityBoost.Addr(), 2, uintptr(process), uintptr(_p0), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetProcessShutdownParameters(level uint32, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetProcessShutdownParameters.Addr(), 2, uintptr(level), uintptr(flags), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetProcessWorkingSetSizeEx(hProcess Handle, dwMinimumWorkingSetSize uintptr, dwMaximumWorkingSetSize uintptr, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetProcessWorkingSetSizeEx.Addr(), 4, uintptr(hProcess), uintptr(dwMinimumWorkingSetSize), uintptr(dwMaximumWorkingSetSize), uintptr(flags), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetStdHandle(stdhandle uint32, handle Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetStdHandle.Addr(), 2, uintptr(stdhandle), uintptr(handle), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetVolumeLabel(rootPathName *uint16, volumeName *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetVolumeLabelW.Addr(), 2, uintptr(unsafe.Pointer(rootPathName)), uintptr(unsafe.Pointer(volumeName)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetVolumeMountPoint(volumeMountPoint *uint16, volumeName *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetVolumeMountPointW.Addr(), 2, uintptr(unsafe.Pointer(volumeMountPoint)), uintptr(unsafe.Pointer(volumeName)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SizeofResource(module Handle, resInfo Handle) (size uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procSizeofResource.Addr(), 2, uintptr(module), uintptr(resInfo), 0)
size = uint32(r0)
if size == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SleepEx(milliseconds uint32, alertable bool) (ret uint32) {</p>

<pre>var _p0 uint32
if alertable {
        _p0 = 1
}
r0, _, _ := syscall.Syscall(procSleepEx.Addr(), 2, uintptr(milliseconds), uintptr(_p0), 0)
ret = uint32(r0)
return</pre>

<p>}</p>

<p>func TerminateJobObject(job Handle, exitCode uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procTerminateJobObject.Addr(), 2, uintptr(job), uintptr(exitCode), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func TerminateProcess(handle Handle, exitcode uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procTerminateProcess.Addr(), 2, uintptr(handle), uintptr(exitcode), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Thread32First(snapshot Handle, threadEntry *ThreadEntry32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procThread32First.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(threadEntry)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Thread32Next(snapshot Handle, threadEntry *ThreadEntry32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procThread32Next.Addr(), 2, uintptr(snapshot), uintptr(unsafe.Pointer(threadEntry)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func UnlockFileEx(file Handle, reserved uint32, bytesLow uint32, bytesHigh uint32, overlapped *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procUnlockFileEx.Addr(), 5, uintptr(file), uintptr(reserved), uintptr(bytesLow), uintptr(bytesHigh), uintptr(unsafe.Pointer(overlapped)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func UnmapViewOfFile(addr uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procUnmapViewOfFile.Addr(), 1, uintptr(addr), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func updateProcThreadAttribute(attrlist *ProcThreadAttributeList, flags uint32, attr uintptr, value unsafe.Pointer, size uintptr, prevvalue unsafe.Pointer, returnedsize *uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procUpdateProcThreadAttribute.Addr(), 7, uintptr(unsafe.Pointer(attrlist)), uintptr(flags), uintptr(attr), uintptr(value), uintptr(size), uintptr(prevvalue), uintptr(unsafe.Pointer(returnedsize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualAlloc(address uintptr, size uintptr, alloctype uint32, protect uint32) (value uintptr, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procVirtualAlloc.Addr(), 4, uintptr(address), uintptr(size), uintptr(alloctype), uintptr(protect), 0, 0)
value = uintptr(r0)
if value == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualFree(address uintptr, size uintptr, freetype uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procVirtualFree.Addr(), 3, uintptr(address), uintptr(size), uintptr(freetype))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualLock(addr uintptr, length uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procVirtualLock.Addr(), 2, uintptr(addr), uintptr(length), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualProtect(address uintptr, size uintptr, newprotect uint32, oldprotect *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procVirtualProtect.Addr(), 4, uintptr(address), uintptr(size), uintptr(newprotect), uintptr(unsafe.Pointer(oldprotect)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualProtectEx(process Handle, address uintptr, size uintptr, newProtect uint32, oldProtect *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procVirtualProtectEx.Addr(), 5, uintptr(process), uintptr(address), uintptr(size), uintptr(newProtect), uintptr(unsafe.Pointer(oldProtect)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualQuery(address uintptr, buffer *MemoryBasicInformation, length uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procVirtualQuery.Addr(), 3, uintptr(address), uintptr(unsafe.Pointer(buffer)), uintptr(length))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualQueryEx(process Handle, address uintptr, buffer *MemoryBasicInformation, length uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procVirtualQueryEx.Addr(), 4, uintptr(process), uintptr(address), uintptr(unsafe.Pointer(buffer)), uintptr(length), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VirtualUnlock(addr uintptr, length uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procVirtualUnlock.Addr(), 2, uintptr(addr), uintptr(length), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WTSGetActiveConsoleSessionId() (sessionID uint32) {</p>

<pre>r0, _, _ := syscall.Syscall(procWTSGetActiveConsoleSessionId.Addr(), 0, 0, 0, 0)
sessionID = uint32(r0)
return</pre>

<p>}</p>

<p>func waitForMultipleObjects(count uint32, handles uintptr, waitAll bool, waitMilliseconds uint32) (event uint32, err error) {</p>

<pre>var _p0 uint32
if waitAll {
        _p0 = 1
}
r0, _, e1 := syscall.Syscall6(procWaitForMultipleObjects.Addr(), 4, uintptr(count), uintptr(handles), uintptr(_p0), uintptr(waitMilliseconds), 0, 0)
event = uint32(r0)
if event == 0xffffffff {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WaitForSingleObject(handle Handle, waitMilliseconds uint32) (event uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procWaitForSingleObject.Addr(), 2, uintptr(handle), uintptr(waitMilliseconds), 0)
event = uint32(r0)
if event == 0xffffffff {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WriteConsole(console Handle, buf *uint16, towrite uint32, written *uint32, reserved *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procWriteConsoleW.Addr(), 5, uintptr(console), uintptr(unsafe.Pointer(buf)), uintptr(towrite), uintptr(unsafe.Pointer(written)), uintptr(unsafe.Pointer(reserved)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func writeFile(handle Handle, buf []byte, done *uint32, overlapped *Overlapped) (err error) {</p>

<pre>var _p0 *byte
if len(buf) &gt; 0 {
        _p0 = &amp;buf[0]
}
r1, _, e1 := syscall.Syscall6(procWriteFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(unsafe.Pointer(done)), uintptr(unsafe.Pointer(overlapped)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WriteProcessMemory(process Handle, baseAddress uintptr, buffer *byte, size uintptr, numberOfBytesWritten *uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procWriteProcessMemory.Addr(), 5, uintptr(process), uintptr(baseAddress), uintptr(unsafe.Pointer(buffer)), uintptr(size), uintptr(unsafe.Pointer(numberOfBytesWritten)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func AcceptEx(ls Handle, as Handle, buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, recvd *uint32, overlapped *Overlapped) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procAcceptEx.Addr(), 8, uintptr(ls), uintptr(as), uintptr(unsafe.Pointer(buf)), uintptr(rxdatalen), uintptr(laddrlen), uintptr(raddrlen), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(overlapped)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetAcceptExSockaddrs(buf *byte, rxdatalen uint32, laddrlen uint32, raddrlen uint32, lrsa **RawSockaddrAny, lrsalen *int32, rrsa **RawSockaddrAny, rrsalen *int32) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall9</span>(<span class="ruby-identifier">procGetAcceptExSockaddrs</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">8</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">buf</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">rxdatalen</span>), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">laddrlen</span>), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">raddrlen</span>), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">lrsa</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">lrsalen</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">rrsa</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">rrsalen</span>)), <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func TransmitFile(s Handle, handle Handle, bytesToWrite uint32, bytsPerSend uint32, overlapped *Overlapped, transmitFileBuf *TransmitFileBuffers, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procTransmitFile.Addr(), 7, uintptr(s), uintptr(handle), uintptr(bytesToWrite), uintptr(bytsPerSend), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(transmitFileBuf)), uintptr(flags), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func NetApiBufferFree(buf *byte) (neterr error) {</p>

<pre>r0, _, _ := syscall.Syscall(procNetApiBufferFree.Addr(), 1, uintptr(unsafe.Pointer(buf)), 0, 0)
if r0 != 0 {
        neterr = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func NetGetJoinInformation(server *uint16, name **uint16, bufType *uint32) (neterr error) {</p>

<pre>r0, _, _ := syscall.Syscall(procNetGetJoinInformation.Addr(), 3, uintptr(unsafe.Pointer(server)), uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(bufType)))
if r0 != 0 {
        neterr = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func NetUserGetInfo(serverName *uint16, userName *uint16, level uint32, buf **byte) (neterr error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procNetUserGetInfo.Addr(), 4, uintptr(unsafe.Pointer(serverName)), uintptr(unsafe.Pointer(userName)), uintptr(level), uintptr(unsafe.Pointer(buf)), 0, 0)
if r0 != 0 {
        neterr = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func NtCreateFile(handle *Handle, access uint32, oa *OBJECT_ATTRIBUTES, iosb *IO_STATUS_BLOCK, allocationSize *int64, attributes uint32, share uint32, disposition uint32, options uint32, eabuffer uintptr, ealength uint32) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall12(procNtCreateFile.Addr(), 11, uintptr(unsafe.Pointer(handle)), uintptr(access), uintptr(unsafe.Pointer(oa)), uintptr(unsafe.Pointer(iosb)), uintptr(unsafe.Pointer(allocationSize)), uintptr(attributes), uintptr(share), uintptr(disposition), uintptr(options), uintptr(eabuffer), uintptr(ealength), 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func NtCreateNamedPipeFile(pipe *Handle, access uint32, oa *OBJECT_ATTRIBUTES, iosb *IO_STATUS_BLOCK, share uint32, disposition uint32, options uint32, typ uint32, readMode uint32, completionMode uint32, maxInstances uint32, inboundQuota uint32, outputQuota uint32, timeout *int64) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall15(procNtCreateNamedPipeFile.Addr(), 14, uintptr(unsafe.Pointer(pipe)), uintptr(access), uintptr(unsafe.Pointer(oa)), uintptr(unsafe.Pointer(iosb)), uintptr(share), uintptr(disposition), uintptr(options), uintptr(typ), uintptr(readMode), uintptr(completionMode), uintptr(maxInstances), uintptr(inboundQuota), uintptr(outputQuota), uintptr(unsafe.Pointer(timeout)), 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func NtQueryInformationProcess(proc Handle, procInfoClass int32, procInfo unsafe.Pointer, procInfoLen uint32, retLen *uint32) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procNtQueryInformationProcess.Addr(), 5, uintptr(proc), uintptr(procInfoClass), uintptr(procInfo), uintptr(procInfoLen), uintptr(unsafe.Pointer(retLen)), 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func NtQuerySystemInformation(sysInfoClass int32, sysInfo unsafe.Pointer, sysInfoLen uint32, retLen *uint32) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procNtQuerySystemInformation.Addr(), 4, uintptr(sysInfoClass), uintptr(sysInfo), uintptr(sysInfoLen), uintptr(unsafe.Pointer(retLen)), 0, 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func NtSetInformationFile(handle Handle, iosb *IO_STATUS_BLOCK, inBuffer *byte, inBufferLen uint32, class uint32) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procNtSetInformationFile.Addr(), 5, uintptr(handle), uintptr(unsafe.Pointer(iosb)), uintptr(unsafe.Pointer(inBuffer)), uintptr(inBufferLen), uintptr(class), 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func NtSetInformationProcess(proc Handle, procInfoClass int32, procInfo unsafe.Pointer, procInfoLen uint32) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procNtSetInformationProcess.Addr(), 4, uintptr(proc), uintptr(procInfoClass), uintptr(procInfo), uintptr(procInfoLen), 0, 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func NtSetSystemInformation(sysInfoClass int32, sysInfo unsafe.Pointer, sysInfoLen uint32) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall(procNtSetSystemInformation.Addr(), 3, uintptr(sysInfoClass), uintptr(sysInfo), uintptr(sysInfoLen))
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func RtlAddFunctionTable(functionTable *RUNTIME_FUNCTION, entryCount uint32, baseAddress uintptr) (ret bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procRtlAddFunctionTable.Addr(), 3, uintptr(unsafe.Pointer(functionTable)), uintptr(entryCount), uintptr(baseAddress))
ret = r0 != 0
return</pre>

<p>}</p>

<p>func RtlDefaultNpAcl(acl **ACL) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall(procRtlDefaultNpAcl.Addr(), 1, uintptr(unsafe.Pointer(acl)), 0, 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func RtlDeleteFunctionTable(functionTable *RUNTIME_FUNCTION) (ret bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procRtlDeleteFunctionTable.Addr(), 1, uintptr(unsafe.Pointer(functionTable)), 0, 0)
ret = r0 != 0
return</pre>

<p>}</p>

<p>func RtlDosPathNameToNtPathName(dosName *uint16, ntName *NTUnicodeString, ntFileNamePart *uint16, relativeName *RTL_RELATIVE_NAME) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procRtlDosPathNameToNtPathName_U_WithStatus.Addr(), 4, uintptr(unsafe.Pointer(dosName)), uintptr(unsafe.Pointer(ntName)), uintptr(unsafe.Pointer(ntFileNamePart)), uintptr(unsafe.Pointer(relativeName)), 0, 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func RtlDosPathNameToRelativeNtPathName(dosName *uint16, ntName *NTUnicodeString, ntFileNamePart *uint16, relativeName *RTL_RELATIVE_NAME) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procRtlDosPathNameToRelativeNtPathName_U_WithStatus.Addr(), 4, uintptr(unsafe.Pointer(dosName)), uintptr(unsafe.Pointer(ntName)), uintptr(unsafe.Pointer(ntFileNamePart)), uintptr(unsafe.Pointer(relativeName)), 0, 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func RtlGetCurrentPeb() (peb *PEB) {</p>

<pre>r0, _, _ := syscall.Syscall(procRtlGetCurrentPeb.Addr(), 0, 0, 0, 0)
peb = (*PEB)(unsafe.Pointer(r0))
return</pre>

<p>}</p>

<p>func rtlGetNtVersionNumbers(majorVersion *uint32, minorVersion *uint32, buildNumber *uint32) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procRtlGetNtVersionNumbers</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">3</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">majorVersion</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">minorVersion</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">buildNumber</span>)))
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func rtlGetVersion(info *OsVersionInfoEx) (ntstatus error) {</p>

<pre>r0, _, _ := syscall.Syscall(procRtlGetVersion.Addr(), 1, uintptr(unsafe.Pointer(info)), 0, 0)
if r0 != 0 {
        ntstatus = NTStatus(r0)
}
return</pre>

<p>}</p>

<p>func RtlInitString(destinationString *NTString, sourceString *byte) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procRtlInitString</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">2</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">destinationString</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">sourceString</span>)), <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func RtlInitUnicodeString(destinationString *NTUnicodeString, sourceString *uint16) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procRtlInitUnicodeString</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">2</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">destinationString</span>)), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">sourceString</span>)), <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func rtlNtStatusToDosErrorNoTeb(ntstatus NTStatus) (ret syscall.Errno) {</p>

<pre>r0, _, _ := syscall.Syscall(procRtlNtStatusToDosErrorNoTeb.Addr(), 1, uintptr(ntstatus), 0, 0)
ret = syscall.Errno(r0)
return</pre>

<p>}</p>

<p>func clsidFromString(lpsz *uint16, pclsid *GUID) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall(procCLSIDFromString.Addr(), 2, uintptr(unsafe.Pointer(lpsz)), uintptr(unsafe.Pointer(pclsid)), 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func coCreateGuid(pguid *GUID) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall(procCoCreateGuid.Addr(), 1, uintptr(unsafe.Pointer(pguid)), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func CoGetObject(name *uint16, bindOpts *BIND_OPTS3, guid *GUID, functionTable **uintptr) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procCoGetObject.Addr(), 4, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(bindOpts)), uintptr(unsafe.Pointer(guid)), uintptr(unsafe.Pointer(functionTable)), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func CoInitializeEx(reserved uintptr, coInit uint32) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall(procCoInitializeEx.Addr(), 2, uintptr(reserved), uintptr(coInit), 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func CoTaskMemFree(address unsafe.Pointer) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procCoTaskMemFree</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">address</span>), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func CoUninitialize() {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procCoUninitialize</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func stringFromGUID2(rguid *GUID, lpsz *uint16, cchMax int32) (chars int32) {</p>

<pre>r0, _, _ := syscall.Syscall(procStringFromGUID2.Addr(), 3, uintptr(unsafe.Pointer(rguid)), uintptr(unsafe.Pointer(lpsz)), uintptr(cchMax))
chars = int32(r0)
return</pre>

<p>}</p>

<p>func EnumProcessModules(process Handle, module *Handle, cb uint32, cbNeeded *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procEnumProcessModules.Addr(), 4, uintptr(process), uintptr(unsafe.Pointer(module)), uintptr(cb), uintptr(unsafe.Pointer(cbNeeded)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func EnumProcessModulesEx(process Handle, module *Handle, cb uint32, cbNeeded *uint32, filterFlag uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procEnumProcessModulesEx.Addr(), 5, uintptr(process), uintptr(unsafe.Pointer(module)), uintptr(cb), uintptr(unsafe.Pointer(cbNeeded)), uintptr(filterFlag), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func EnumProcesses(processIds []uint32, bytesReturned *uint32) (err error) {</p>

<pre>var _p0 *uint32
if len(processIds) &gt; 0 {
        _p0 = &amp;processIds[0]
}
r1, _, e1 := syscall.Syscall(procEnumProcesses.Addr(), 3, uintptr(unsafe.Pointer(_p0)), uintptr(len(processIds)), uintptr(unsafe.Pointer(bytesReturned)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetModuleBaseName(process Handle, module Handle, baseName *uint16, size uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetModuleBaseNameW.Addr(), 4, uintptr(process), uintptr(module), uintptr(unsafe.Pointer(baseName)), uintptr(size), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetModuleFileNameEx(process Handle, module Handle, filename *uint16, size uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetModuleFileNameExW.Addr(), 4, uintptr(process), uintptr(module), uintptr(unsafe.Pointer(filename)), uintptr(size), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetModuleInformation(process Handle, module Handle, modinfo *ModuleInfo, cb uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetModuleInformation.Addr(), 4, uintptr(process), uintptr(module), uintptr(unsafe.Pointer(modinfo)), uintptr(cb), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func QueryWorkingSetEx(process Handle, pv uintptr, cb uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procQueryWorkingSetEx.Addr(), 3, uintptr(process), uintptr(pv), uintptr(cb))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SubscribeServiceChangeNotifications(service Handle, eventType uint32, callback uintptr, callbackCtx uintptr, subscription *uintptr) (ret error) {</p>

<pre>ret = procSubscribeServiceChangeNotifications.Find()
if ret != nil {
        return
}
r0, _, _ := syscall.Syscall6(procSubscribeServiceChangeNotifications.Addr(), 5, uintptr(service), uintptr(eventType), uintptr(callback), uintptr(callbackCtx), uintptr(unsafe.Pointer(subscription)), 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func UnsubscribeServiceChangeNotifications(subscription uintptr) (err error) {</p>

<pre>err = procUnsubscribeServiceChangeNotifications.Find()
if err != nil {
        return
}
syscall.Syscall(procUnsubscribeServiceChangeNotifications.Addr(), 1, uintptr(subscription), 0, 0)
return</pre>

<p>}</p>

<p>func GetUserNameEx(nameFormat uint32, nameBuffre *uint16, nSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetUserNameExW.Addr(), 3, uintptr(nameFormat), uintptr(unsafe.Pointer(nameBuffre)), uintptr(unsafe.Pointer(nSize)))
if r1&amp;0xff == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func TranslateName(accName *uint16, accNameFormat uint32, desiredNameFormat uint32, translatedName *uint16, nSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procTranslateNameW.Addr(), 5, uintptr(unsafe.Pointer(accName)), uintptr(accNameFormat), uintptr(desiredNameFormat), uintptr(unsafe.Pointer(translatedName)), uintptr(unsafe.Pointer(nSize)), 0)
if r1&amp;0xff == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiBuildDriverInfoList(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverType SPDIT) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiBuildDriverInfoList.Addr(), 3, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(driverType))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiCallClassInstaller(installFunction DI_FUNCTION, deviceInfoSet DevInfo, deviceInfoData *DevInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiCallClassInstaller.Addr(), 3, uintptr(installFunction), uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiCancelDriverInfoSearch(deviceInfoSet DevInfo) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiCancelDriverInfoSearch.Addr(), 1, uintptr(deviceInfoSet), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiClassGuidsFromNameEx(className *uint16, classGuidList *GUID, classGuidListSize uint32, requiredSize *uint32, machineName *uint16, reserved uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiClassGuidsFromNameExW.Addr(), 6, uintptr(unsafe.Pointer(className)), uintptr(unsafe.Pointer(classGuidList)), uintptr(classGuidListSize), uintptr(unsafe.Pointer(requiredSize)), uintptr(unsafe.Pointer(machineName)), uintptr(reserved))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiClassNameFromGuidEx(classGUID *GUID, className *uint16, classNameSize uint32, requiredSize *uint32, machineName *uint16, reserved uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiClassNameFromGuidExW.Addr(), 6, uintptr(unsafe.Pointer(classGUID)), uintptr(unsafe.Pointer(className)), uintptr(classNameSize), uintptr(unsafe.Pointer(requiredSize)), uintptr(unsafe.Pointer(machineName)), uintptr(reserved))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiCreateDeviceInfoListEx(classGUID *GUID, hwndParent uintptr, machineName *uint16, reserved uintptr) (handle DevInfo, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procSetupDiCreateDeviceInfoListExW.Addr(), 4, uintptr(unsafe.Pointer(classGUID)), uintptr(hwndParent), uintptr(unsafe.Pointer(machineName)), uintptr(reserved), 0, 0)
handle = DevInfo(r0)
if handle == DevInfo(InvalidHandle) {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiCreateDeviceInfo(deviceInfoSet DevInfo, DeviceName *uint16, classGUID *GUID, DeviceDescription *uint16, hwndParent uintptr, CreationFlags DICD, deviceInfoData *DevInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procSetupDiCreateDeviceInfoW.Addr(), 7, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(DeviceName)), uintptr(unsafe.Pointer(classGUID)), uintptr(unsafe.Pointer(DeviceDescription)), uintptr(hwndParent), uintptr(CreationFlags), uintptr(unsafe.Pointer(deviceInfoData)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiDestroyDeviceInfoList(deviceInfoSet DevInfo) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiDestroyDeviceInfoList.Addr(), 1, uintptr(deviceInfoSet), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiDestroyDriverInfoList(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverType SPDIT) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiDestroyDriverInfoList.Addr(), 3, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(driverType))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiEnumDeviceInfo(deviceInfoSet DevInfo, memberIndex uint32, deviceInfoData *DevInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiEnumDeviceInfo.Addr(), 3, uintptr(deviceInfoSet), uintptr(memberIndex), uintptr(unsafe.Pointer(deviceInfoData)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiEnumDriverInfo(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverType SPDIT, memberIndex uint32, driverInfoData *DrvInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiEnumDriverInfoW.Addr(), 5, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(driverType), uintptr(memberIndex), uintptr(unsafe.Pointer(driverInfoData)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetClassDevsEx(classGUID *GUID, Enumerator *uint16, hwndParent uintptr, Flags DIGCF, deviceInfoSet DevInfo, machineName *uint16, reserved uintptr) (handle DevInfo, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall9(procSetupDiGetClassDevsExW.Addr(), 7, uintptr(unsafe.Pointer(classGUID)), uintptr(unsafe.Pointer(Enumerator)), uintptr(hwndParent), uintptr(Flags), uintptr(deviceInfoSet), uintptr(unsafe.Pointer(machineName)), uintptr(reserved), 0, 0)
handle = DevInfo(r0)
if handle == DevInfo(InvalidHandle) {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiGetClassInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, classInstallParams *ClassInstallHeader, classInstallParamsSize uint32, requiredSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiGetClassInstallParamsW.Addr(), 5, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(classInstallParams)), uintptr(classInstallParamsSize), uintptr(unsafe.Pointer(requiredSize)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetDeviceInfoListDetail(deviceInfoSet DevInfo, deviceInfoSetDetailData *DevInfoListDetailData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiGetDeviceInfoListDetailW.Addr(), 2, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoSetDetailData)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetDeviceInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, deviceInstallParams *DevInstallParams) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiGetDeviceInstallParamsW.Addr(), 3, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(deviceInstallParams)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetDeviceInstanceId(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, instanceId *uint16, instanceIdSize uint32, instanceIdRequiredSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiGetDeviceInstanceIdW.Addr(), 5, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(instanceId)), uintptr(instanceIdSize), uintptr(unsafe.Pointer(instanceIdRequiredSize)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetDeviceProperty(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, propertyKey *DEVPROPKEY, propertyType *DEVPROPTYPE, propertyBuffer *byte, propertyBufferSize uint32, requiredSize *uint32, flags uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procSetupDiGetDevicePropertyW.Addr(), 8, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(propertyKey)), uintptr(unsafe.Pointer(propertyType)), uintptr(unsafe.Pointer(propertyBuffer)), uintptr(propertyBufferSize), uintptr(unsafe.Pointer(requiredSize)), uintptr(flags), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetDeviceRegistryProperty(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, property SPDRP, propertyRegDataType *uint32, propertyBuffer *byte, propertyBufferSize uint32, requiredSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procSetupDiGetDeviceRegistryPropertyW.Addr(), 7, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(property), uintptr(unsafe.Pointer(propertyRegDataType)), uintptr(unsafe.Pointer(propertyBuffer)), uintptr(propertyBufferSize), uintptr(unsafe.Pointer(requiredSize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetDriverInfoDetail(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverInfoData *DrvInfoData, driverInfoDetailData *DrvInfoDetailData, driverInfoDetailDataSize uint32, requiredSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiGetDriverInfoDetailW.Addr(), 6, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(driverInfoData)), uintptr(unsafe.Pointer(driverInfoDetailData)), uintptr(driverInfoDetailDataSize), uintptr(unsafe.Pointer(requiredSize)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetSelectedDevice(deviceInfoSet DevInfo, deviceInfoData *DevInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiGetSelectedDevice.Addr(), 2, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiGetSelectedDriver(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverInfoData *DrvInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiGetSelectedDriverW.Addr(), 3, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(driverInfoData)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiOpenDevRegKey(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, Scope DICS_FLAG, HwProfile uint32, KeyType DIREG, samDesired uint32) (key Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procSetupDiOpenDevRegKey.Addr(), 6, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(Scope), uintptr(HwProfile), uintptr(KeyType), uintptr(samDesired))
key = Handle(r0)
if key == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiSetClassInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, classInstallParams *ClassInstallHeader, classInstallParamsSize uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiSetClassInstallParamsW.Addr(), 4, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(classInstallParams)), uintptr(classInstallParamsSize), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiSetDeviceInstallParams(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, deviceInstallParams *DevInstallParams) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiSetDeviceInstallParamsW.Addr(), 3, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(deviceInstallParams)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupDiSetDeviceRegistryProperty(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, property SPDRP, propertyBuffer *byte, propertyBufferSize uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procSetupDiSetDeviceRegistryPropertyW.Addr(), 5, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(property), uintptr(unsafe.Pointer(propertyBuffer)), uintptr(propertyBufferSize), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiSetSelectedDevice(deviceInfoSet DevInfo, deviceInfoData *DevInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiSetSelectedDevice.Addr(), 2, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func SetupDiSetSelectedDriver(deviceInfoSet DevInfo, deviceInfoData *DevInfoData, driverInfoData *DrvInfoData) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupDiSetSelectedDriverW.Addr(), 3, uintptr(deviceInfoSet), uintptr(unsafe.Pointer(deviceInfoData)), uintptr(unsafe.Pointer(driverInfoData)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func setupUninstallOEMInf(infFileName *uint16, flags SUOI, reserved uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procSetupUninstallOEMInfW.Addr(), 3, uintptr(unsafe.Pointer(infFileName)), uintptr(flags), uintptr(reserved))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CommandLineToArgv(cmd *uint16, argc *int32) (argv <strong>[8192]</strong>[8192]uint16, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procCommandLineToArgvW.Addr(), 2, uintptr(unsafe.Pointer(cmd)), uintptr(unsafe.Pointer(argc)), 0)
argv = (*[8192]*[8192]uint16)(unsafe.Pointer(r0))
if argv == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func shGetKnownFolderPath(id *KNOWNFOLDERID, flags uint32, token Token, path **uint16) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procSHGetKnownFolderPath.Addr(), 4, uintptr(unsafe.Pointer(id)), uintptr(flags), uintptr(token), uintptr(unsafe.Pointer(path)), 0, 0)
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func ShellExecute(hwnd Handle, verb *uint16, file *uint16, args *uint16, cwd *uint16, showCmd int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procShellExecuteW.Addr(), 6, uintptr(hwnd), uintptr(unsafe.Pointer(verb)), uintptr(unsafe.Pointer(file)), uintptr(unsafe.Pointer(args)), uintptr(unsafe.Pointer(cwd)), uintptr(showCmd))
if r1 &lt;= 32 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func EnumChildWindows(hwnd HWND, enumFunc uintptr, param unsafe.Pointer) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procEnumChildWindows</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">3</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">hwnd</span>), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">enumFunc</span>), <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">param</span>))
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func EnumWindows(enumFunc uintptr, param unsafe.Pointer) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procEnumWindows.Addr(), 2, uintptr(enumFunc), uintptr(param), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func ExitWindowsEx(flags uint32, reason uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procExitWindowsEx.Addr(), 2, uintptr(flags), uintptr(reason), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetClassName(hwnd HWND, className *uint16, maxCount int32) (copied int32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetClassNameW.Addr(), 3, uintptr(hwnd), uintptr(unsafe.Pointer(className)), uintptr(maxCount))
copied = int32(r0)
if copied == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetDesktopWindow() (hwnd HWND) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetDesktopWindow.Addr(), 0, 0, 0, 0)
hwnd = HWND(r0)
return</pre>

<p>}</p>

<p>func GetForegroundWindow() (hwnd HWND) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetForegroundWindow.Addr(), 0, 0, 0, 0)
hwnd = HWND(r0)
return</pre>

<p>}</p>

<p>func GetGUIThreadInfo(thread uint32, info *GUIThreadInfo) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetGUIThreadInfo.Addr(), 2, uintptr(thread), uintptr(unsafe.Pointer(info)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetShellWindow() (shellWindow HWND) {</p>

<pre>r0, _, _ := syscall.Syscall(procGetShellWindow.Addr(), 0, 0, 0, 0)
shellWindow = HWND(r0)
return</pre>

<p>}</p>

<p>func GetWindowThreadProcessId(hwnd HWND, pid *uint32) (tid uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetWindowThreadProcessId.Addr(), 2, uintptr(hwnd), uintptr(unsafe.Pointer(pid)), 0)
tid = uint32(r0)
if tid == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func IsWindow(hwnd HWND) (isWindow bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procIsWindow.Addr(), 1, uintptr(hwnd), 0, 0)
isWindow = r0 != 0
return</pre>

<p>}</p>

<p>func IsWindowUnicode(hwnd HWND) (isUnicode bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procIsWindowUnicode.Addr(), 1, uintptr(hwnd), 0, 0)
isUnicode = r0 != 0
return</pre>

<p>}</p>

<p>func IsWindowVisible(hwnd HWND) (isVisible bool) {</p>

<pre>r0, _, _ := syscall.Syscall(procIsWindowVisible.Addr(), 1, uintptr(hwnd), 0, 0)
isVisible = r0 != 0
return</pre>

<p>}</p>

<p>func MessageBox(hwnd HWND, text *uint16, caption *uint16, boxtype uint32) (ret int32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procMessageBoxW.Addr(), 4, uintptr(hwnd), uintptr(unsafe.Pointer(text)), uintptr(unsafe.Pointer(caption)), uintptr(boxtype), 0, 0)
ret = int32(r0)
if ret == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func CreateEnvironmentBlock(block **uint16, token Token, inheritExisting bool) (err error) {</p>

<pre>var _p0 uint32
if inheritExisting {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall(procCreateEnvironmentBlock.Addr(), 3, uintptr(unsafe.Pointer(block)), uintptr(token), uintptr(_p0))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func DestroyEnvironmentBlock(block *uint16) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procDestroyEnvironmentBlock.Addr(), 1, uintptr(unsafe.Pointer(block)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetUserProfileDirectory(t Token, dir *uint16, dirLen *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procGetUserProfileDirectoryW.Addr(), 3, uintptr(t), uintptr(unsafe.Pointer(dir)), uintptr(unsafe.Pointer(dirLen)))
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileVersionInfoSize(filename string, zeroHandle *Handle) (bufSize uint32, err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(filename)
if err != nil {
        return
}
return _GetFileVersionInfoSize(_p0, zeroHandle)</pre>

<p>}</p>

<p>func _GetFileVersionInfoSize(filename *uint16, zeroHandle *Handle) (bufSize uint32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procGetFileVersionInfoSizeW.Addr(), 2, uintptr(unsafe.Pointer(filename)), uintptr(unsafe.Pointer(zeroHandle)), 0)
bufSize = uint32(r0)
if bufSize == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetFileVersionInfo(filename string, handle uint32, bufSize uint32, buffer unsafe.Pointer) (err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(filename)
if err != nil {
        return
}
return _GetFileVersionInfo(_p0, handle, bufSize, buffer)</pre>

<p>}</p>

<p>func _GetFileVersionInfo(filename *uint16, handle uint32, bufSize uint32, buffer unsafe.Pointer) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procGetFileVersionInfoW.Addr(), 4, uintptr(unsafe.Pointer(filename)), uintptr(handle), uintptr(bufSize), uintptr(buffer), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func VerQueryValue(block unsafe.Pointer, subBlock string, pointerToBufferPointer unsafe.Pointer, bufSize *uint32) (err error) {</p>

<pre>var _p0 *uint16
_p0, err = syscall.UTF16PtrFromString(subBlock)
if err != nil {
        return
}
return _VerQueryValue(block, _p0, pointerToBufferPointer, bufSize)</pre>

<p>}</p>

<p>func _VerQueryValue(block unsafe.Pointer, subBlock *uint16, pointerToBufferPointer unsafe.Pointer, bufSize *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procVerQueryValueW.Addr(), 4, uintptr(block), uintptr(unsafe.Pointer(subBlock)), uintptr(pointerToBufferPointer), uintptr(unsafe.Pointer(bufSize)), 0, 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WinVerifyTrustEx(hwnd HWND, actionId *GUID, data *WinTrustData) (ret error) {</p>

<pre>r0, _, _ := syscall.Syscall(procWinVerifyTrustEx.Addr(), 3, uintptr(hwnd), uintptr(unsafe.Pointer(actionId)), uintptr(unsafe.Pointer(data)))
if r0 != 0 {
        ret = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func FreeAddrInfoW(addrinfo *AddrinfoW) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procFreeAddrInfoW</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">unsafe</span>.<span class="ruby-constant">Pointer</span>(<span class="ruby-identifier">addrinfo</span>)), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func GetAddrInfoW(nodename *uint16, servicename *uint16, hints *AddrinfoW, result **AddrinfoW) (sockerr error) {</p>

<pre>r0, _, _ := syscall.Syscall6(procGetAddrInfoW.Addr(), 4, uintptr(unsafe.Pointer(nodename)), uintptr(unsafe.Pointer(servicename)), uintptr(unsafe.Pointer(hints)), uintptr(unsafe.Pointer(result)), 0, 0)
if r0 != 0 {
        sockerr = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func WSACleanup() (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procWSACleanup.Addr(), 0, 0, 0, 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSAEnumProtocols(protocols *int32, protocolBuffer *WSAProtocolInfo, bufferLength *uint32) (n int32, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procWSAEnumProtocolsW.Addr(), 3, uintptr(unsafe.Pointer(protocols)), uintptr(unsafe.Pointer(protocolBuffer)), uintptr(unsafe.Pointer(bufferLength)))
n = int32(r0)
if n == -1 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSAGetOverlappedResult(h Handle, o *Overlapped, bytes *uint32, wait bool, flags *uint32) (err error) {</p>

<pre>var _p0 uint32
if wait {
        _p0 = 1
}
r1, _, e1 := syscall.Syscall6(procWSAGetOverlappedResult.Addr(), 5, uintptr(h), uintptr(unsafe.Pointer(o)), uintptr(unsafe.Pointer(bytes)), uintptr(_p0), uintptr(unsafe.Pointer(flags)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSAIoctl(s Handle, iocc uint32, inbuf *byte, cbif uint32, outbuf *byte, cbob uint32, cbbr *uint32, overlapped *Overlapped, completionRoutine uintptr) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procWSAIoctl.Addr(), 9, uintptr(s), uintptr(iocc), uintptr(unsafe.Pointer(inbuf)), uintptr(cbif), uintptr(unsafe.Pointer(outbuf)), uintptr(cbob), uintptr(unsafe.Pointer(cbbr)), uintptr(unsafe.Pointer(overlapped)), uintptr(completionRoutine))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSARecv(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, overlapped *Overlapped, croutine *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procWSARecv.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSARecvFrom(s Handle, bufs *WSABuf, bufcnt uint32, recvd *uint32, flags *uint32, from *RawSockaddrAny, fromlen *int32, overlapped *Overlapped, croutine *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procWSARecvFrom.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(recvd)), uintptr(unsafe.Pointer(flags)), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSASend(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, overlapped *Overlapped, croutine *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procWSASend.Addr(), 7, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)), 0, 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSASendTo(s Handle, bufs *WSABuf, bufcnt uint32, sent *uint32, flags uint32, to *RawSockaddrAny, tolen int32, overlapped *Overlapped, croutine *byte) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall9(procWSASendTo.Addr(), 9, uintptr(s), uintptr(unsafe.Pointer(bufs)), uintptr(bufcnt), uintptr(unsafe.Pointer(sent)), uintptr(flags), uintptr(unsafe.Pointer(to)), uintptr(tolen), uintptr(unsafe.Pointer(overlapped)), uintptr(unsafe.Pointer(croutine)))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSASocket(af int32, typ int32, protocol int32, protoInfo *WSAProtocolInfo, group uint32, flags uint32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall6(procWSASocketW.Addr(), 6, uintptr(af), uintptr(typ), uintptr(protocol), uintptr(unsafe.Pointer(protoInfo)), uintptr(group), uintptr(flags))
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WSAStartup(verreq uint32, data *WSAData) (sockerr error) {</p>

<pre>r0, _, _ := syscall.Syscall(procWSAStartup.Addr(), 2, uintptr(verreq), uintptr(unsafe.Pointer(data)), 0)
if r0 != 0 {
        sockerr = syscall.Errno(r0)
}
return</pre>

<p>}</p>

<p>func bind(s Handle, name unsafe.Pointer, namelen int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procbind.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Closesocket(s Handle) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procclosesocket.Addr(), 1, uintptr(s), 0, 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func connect(s Handle, name unsafe.Pointer, namelen int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procconnect.Addr(), 3, uintptr(s), uintptr(name), uintptr(namelen))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetHostByName(name string) (h *Hostent, err error) {</p>

<pre>var _p0 *byte
_p0, err = syscall.BytePtrFromString(name)
if err != nil {
        return
}
return _GetHostByName(_p0)</pre>

<p>}</p>

<p>func _GetHostByName(name *byte) (h *Hostent, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procgethostbyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
h = (*Hostent)(unsafe.Pointer(r0))
if h == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getpeername(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procgetpeername.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetProtoByName(name string) (p *Protoent, err error) {</p>

<pre>var _p0 *byte
_p0, err = syscall.BytePtrFromString(name)
if err != nil {
        return
}
return _GetProtoByName(_p0)</pre>

<p>}</p>

<p>func _GetProtoByName(name *byte) (p *Protoent, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procgetprotobyname.Addr(), 1, uintptr(unsafe.Pointer(name)), 0, 0)
p = (*Protoent)(unsafe.Pointer(r0))
if p == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func GetServByName(name string, proto string) (s *Servent, err error) {</p>

<pre>var _p0 *byte
_p0, err = syscall.BytePtrFromString(name)
if err != nil {
        return
}
var _p1 *byte
_p1, err = syscall.BytePtrFromString(proto)
if err != nil {
        return
}
return _GetServByName(_p0, _p1)</pre>

<p>}</p>

<p>func _GetServByName(name *byte, proto *byte) (s *Servent, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procgetservbyname.Addr(), 2, uintptr(unsafe.Pointer(name)), uintptr(unsafe.Pointer(proto)), 0)
s = (*Servent)(unsafe.Pointer(r0))
if s == nil {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func getsockname(s Handle, rsa *RawSockaddrAny, addrlen *int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procgetsockname.Addr(), 3, uintptr(s), uintptr(unsafe.Pointer(rsa)), uintptr(unsafe.Pointer(addrlen)))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Getsockopt(s Handle, level int32, optname int32, optval *byte, optlen *int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procgetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(unsafe.Pointer(optlen)), 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func listen(s Handle, backlog int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(proclisten.Addr(), 2, uintptr(s), uintptr(backlog), 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Ntohs(netshort uint16) (u uint16) {</p>

<pre>r0, _, _ := syscall.Syscall(procntohs.Addr(), 1, uintptr(netshort), 0, 0)
u = uint16(r0)
return</pre>

<p>}</p>

<p>func recvfrom(s Handle, buf []byte, flags int32, from *RawSockaddrAny, fromlen *int32) (n int32, err error) {</p>

<pre>var _p0 *byte
if len(buf) &gt; 0 {
        _p0 = &amp;buf[0]
}
r0, _, e1 := syscall.Syscall6(procrecvfrom.Addr(), 6, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(unsafe.Pointer(from)), uintptr(unsafe.Pointer(fromlen)))
n = int32(r0)
if n == -1 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func sendto(s Handle, buf []byte, flags int32, to unsafe.Pointer, tolen int32) (err error) {</p>

<pre>var _p0 *byte
if len(buf) &gt; 0 {
        _p0 = &amp;buf[0]
}
r1, _, e1 := syscall.Syscall6(procsendto.Addr(), 6, uintptr(s), uintptr(unsafe.Pointer(_p0)), uintptr(len(buf)), uintptr(flags), uintptr(to), uintptr(tolen))
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func Setsockopt(s Handle, level int32, optname int32, optval *byte, optlen int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procsetsockopt.Addr(), 5, uintptr(s), uintptr(level), uintptr(optname), uintptr(unsafe.Pointer(optval)), uintptr(optlen), 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func shutdown(s Handle, how int32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procshutdown.Addr(), 2, uintptr(s), uintptr(how), 0)
if r1 == socket_error {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func socket(af int32, typ int32, protocol int32) (handle Handle, err error) {</p>

<pre>r0, _, e1 := syscall.Syscall(procsocket.Addr(), 3, uintptr(af), uintptr(typ), uintptr(protocol))
handle = Handle(r0)
if handle == InvalidHandle {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WTSEnumerateSessions(handle Handle, reserved uint32, version uint32, sessions **WTS_SESSION_INFO, count *uint32) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall6(procWTSEnumerateSessionsW.Addr(), 5, uintptr(handle), uintptr(reserved), uintptr(version), uintptr(unsafe.Pointer(sessions)), uintptr(unsafe.Pointer(count)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

<p>func WTSFreeMemory(ptr uintptr) {</p>

<pre class="ruby"><span class="ruby-identifier">syscall</span>.<span class="ruby-constant">Syscall</span>(<span class="ruby-identifier">procWTSFreeMemory</span>.<span class="ruby-constant">Addr</span>(), <span class="ruby-value">1</span>, <span class="ruby-identifier">uintptr</span>(<span class="ruby-identifier">ptr</span>), <span class="ruby-value">0</span>, <span class="ruby-value">0</span>)
<span class="ruby-keyword">return</span>
</pre>

<p>}</p>

<p>func WTSQueryUserToken(session uint32, token *Token) (err error) {</p>

<pre>r1, _, e1 := syscall.Syscall(procWTSQueryUserToken.Addr(), 2, uintptr(session), uintptr(unsafe.Pointer(token)), 0)
if r1 == 0 {
        err = errnoErr(e1)
}
return</pre>

<p>}</p>

</main>



<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

